const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["assets/opencv-D58UuVCI.js","assets/index-rQLcFmgX.js","assets/ort.bundle.min-D7xVg6BR.js"])))=>i.map(i=>d[i]);
(function(){const t=document.createElement("link").relList;if(t&&t.supports&&t.supports("modulepreload"))return;for(const e of document.querySelectorAll('link[rel="modulepreload"]'))c(e);new MutationObserver(e=>{for(const s of e)if(s.type==="childList")for(const a of s.addedNodes)a.tagName==="LINK"&&a.rel==="modulepreload"&&c(a)}).observe(document,{childList:!0,subtree:!0});function r(e){const s={};return e.integrity&&(s.integrity=e.integrity),e.referrerPolicy&&(s.referrerPolicy=e.referrerPolicy),e.crossOrigin==="use-credentials"?s.credentials="include":e.crossOrigin==="anonymous"?s.credentials="omit":s.credentials="same-origin",s}function c(e){if(e.ep)return;e.ep=!0;const s=r(e);fetch(e.href,s)}})();const Et="modulepreload",Ct=function(n){return"/"+n},ft={},wt=function(t,r,c){let e=Promise.resolve();if(r&&r.length>0){let l=function(i){return Promise.all(i.map(f=>Promise.resolve(f).then(u=>({status:"fulfilled",value:u}),u=>({status:"rejected",reason:u}))))};var a=l;document.getElementsByTagName("link");const o=document.querySelector("meta[property=csp-nonce]"),d=o?.nonce||o?.getAttribute("nonce");e=l(r.map(i=>{if(i=Ct(i),i in ft)return;ft[i]=!0;const f=i.endsWith(".css"),u=f?'[rel="stylesheet"]':"";if(document.querySelector(`link[href="${i}"]${u}`))return;const h=document.createElement("link");if(h.rel=f?"stylesheet":Et,f||(h.as="script"),h.crossOrigin="",h.href=i,d&&h.setAttribute("nonce",d),document.head.appendChild(h),f)return new Promise((w,m)=>{h.addEventListener("load",w),h.addEventListener("error",()=>m(new Error(`Unable to preload CSS for ${i}`)))})}))}function s(o){const d=new Event("vite:preloadError",{cancelable:!0});if(d.payload=o,window.dispatchEvent(d),!d.defaultPrevented)throw o}return e.then(o=>{for(const d of o||[])d.status==="rejected"&&s(d.reason);return t().catch(s)})},xt="/assets/yolov11n-T01ToQ2H.ort",Rt=(n,t)=>{const r=typeof document<"u"?document.createElement("canvas"):new OffscreenCanvas(1,1);r.width=n.dims[3],r.height=n.dims[2];const c=r.getContext("2d");if(c!=null){let e,s;t?.tensorLayout!==void 0&&t.tensorLayout==="NHWC"?(e=n.dims[2],s=n.dims[3]):(e=n.dims[3],s=n.dims[2]);const a=t?.format!==void 0?t.format:"RGB",o=t?.norm;let d,l;o===void 0||o.mean===void 0?d=[255,255,255,255]:typeof o.mean=="number"?d=[o.mean,o.mean,o.mean,o.mean]:(d=[o.mean[0],o.mean[1],o.mean[2],0],o.mean[3]!==void 0&&(d[3]=o.mean[3])),o===void 0||o.bias===void 0?l=[0,0,0,0]:typeof o.bias=="number"?l=[o.bias,o.bias,o.bias,o.bias]:(l=[o.bias[0],o.bias[1],o.bias[2],0],o.bias[3]!==void 0&&(l[3]=o.bias[3]));const i=s*e;let f=0,u=i,h=i*2,w=-1;a==="RGBA"?(f=0,u=i,h=i*2,w=i*3):a==="RGB"?(f=0,u=i,h=i*2):a==="RBG"&&(f=0,h=i,u=i*2);for(let m=0;m<s;m++)for(let g=0;g<e;g++){const p=(n.data[f++]-l[0])*d[0],y=(n.data[u++]-l[1])*d[1],b=(n.data[h++]-l[2])*d[2],A=w===-1?255:(n.data[w++]-l[3])*d[3];c.fillStyle="rgba("+p+","+y+","+b+","+A+")",c.fillRect(g,m,1,1)}if("toDataURL"in r)return r.toDataURL();throw new Error("toDataURL is not supported")}else throw new Error("Can not access image data")},It=(n,t)=>{const r=typeof document<"u"?document.createElement("canvas").getContext("2d"):new OffscreenCanvas(1,1).getContext("2d");let c;if(r!=null){let e,s,a;t?.tensorLayout!==void 0&&t.tensorLayout==="NHWC"?(e=n.dims[2],s=n.dims[1],a=n.dims[3]):(e=n.dims[3],s=n.dims[2],a=n.dims[1]);const o=t!==void 0&&t.format!==void 0?t.format:"RGB",d=t?.norm;let l,i;d===void 0||d.mean===void 0?l=[255,255,255,255]:typeof d.mean=="number"?l=[d.mean,d.mean,d.mean,d.mean]:(l=[d.mean[0],d.mean[1],d.mean[2],255],d.mean[3]!==void 0&&(l[3]=d.mean[3])),d===void 0||d.bias===void 0?i=[0,0,0,0]:typeof d.bias=="number"?i=[d.bias,d.bias,d.bias,d.bias]:(i=[d.bias[0],d.bias[1],d.bias[2],0],d.bias[3]!==void 0&&(i[3]=d.bias[3]));const f=s*e;if(t!==void 0&&(t.format!==void 0&&a===4&&t.format!=="RGBA"||a===3&&t.format!=="RGB"&&t.format!=="BGR"))throw new Error("Tensor format doesn't match input tensor dims");const u=4;let h=0,w=1,m=2,g=3,p=0,y=f,b=f*2,A=-1;o==="RGBA"?(p=0,y=f,b=f*2,A=f*3):o==="RGB"?(p=0,y=f,b=f*2):o==="RBG"&&(p=0,b=f,y=f*2),c=r.createImageData(e,s);for(let E=0;E<s*e;h+=u,w+=u,m+=u,g+=u,E++)c.data[h]=(n.data[p++]-i[0])*l[0],c.data[w]=(n.data[y++]-i[1])*l[1],c.data[m]=(n.data[b++]-i[2])*l[2],c.data[g]=A===-1?255:(n.data[A++]-i[3])*l[3]}else throw new Error("Can not access image data");return c},Z=(n,t)=>{if(n===void 0)throw new Error("Image buffer must be defined");if(t.height===void 0||t.width===void 0)throw new Error("Image height and width must be defined");if(t.tensorLayout==="NHWC")throw new Error("NHWC Tensor layout is not supported yet");const{height:r,width:c}=t,e=t.norm??{mean:255,bias:0};let s,a;typeof e.mean=="number"?s=[e.mean,e.mean,e.mean,e.mean]:s=[e.mean[0],e.mean[1],e.mean[2],e.mean[3]??255],typeof e.bias=="number"?a=[e.bias,e.bias,e.bias,e.bias]:a=[e.bias[0],e.bias[1],e.bias[2],e.bias[3]??0];const o=t.format!==void 0?t.format:"RGBA",d=t.tensorFormat!==void 0&&t.tensorFormat!==void 0?t.tensorFormat:"RGB",l=r*c,i=d==="RGBA"?new Float32Array(l*4):new Float32Array(l*3);let f=4,u=0,h=1,w=2,m=3,g=0,p=l,y=l*2,b=-1;o==="RGB"&&(f=3,u=0,h=1,w=2,m=-1),d==="RGBA"?b=l*3:d==="RBG"?(g=0,y=l,p=l*2):d==="BGR"&&(y=0,p=l,g=l*2);for(let E=0;E<l;E++,u+=f,w+=f,h+=f,m+=f)i[g++]=(n[u]+a[0])/s[0],i[p++]=(n[h]+a[1])/s[1],i[y++]=(n[w]+a[2])/s[2],b!==-1&&m!==-1&&(i[b++]=(n[m]+a[3])/s[3]);return d==="RGBA"?new I("float32",i,[1,4,r,c]):new I("float32",i,[1,3,r,c])},Pt=async(n,t)=>{const r=typeof HTMLImageElement<"u"&&n instanceof HTMLImageElement,c=typeof ImageData<"u"&&n instanceof ImageData,e=typeof ImageBitmap<"u"&&n instanceof ImageBitmap,s=typeof n=="string";let a,o=t??{};const d=()=>{if(typeof document<"u")return document.createElement("canvas");if(typeof OffscreenCanvas<"u")return new OffscreenCanvas(1,1);throw new Error("Canvas is not supported")},l=i=>typeof HTMLCanvasElement<"u"&&i instanceof HTMLCanvasElement||i instanceof OffscreenCanvas?i.getContext("2d"):null;if(r){const i=d();i.width=n.width,i.height=n.height;const f=l(i);if(f!=null){let u=n.height,h=n.width;if(t!==void 0&&t.resizedHeight!==void 0&&t.resizedWidth!==void 0&&(u=t.resizedHeight,h=t.resizedWidth),t!==void 0){if(o=t,t.tensorFormat!==void 0)throw new Error("Image input config format must be RGBA for HTMLImageElement");o.tensorFormat="RGBA",o.height=u,o.width=h}else o.tensorFormat="RGBA",o.height=u,o.width=h;f.drawImage(n,0,0),a=f.getImageData(0,0,h,u).data}else throw new Error("Can not access image data")}else if(c){let i,f;if(t!==void 0&&t.resizedWidth!==void 0&&t.resizedHeight!==void 0?(i=t.resizedHeight,f=t.resizedWidth):(i=n.height,f=n.width),t!==void 0&&(o=t),o.format="RGBA",o.height=i,o.width=f,t!==void 0){const u=d();u.width=f,u.height=i;const h=l(u);if(h!=null)h.putImageData(n,0,0),a=h.getImageData(0,0,f,i).data;else throw new Error("Can not access image data")}else a=n.data}else if(e){if(t===void 0)throw new Error("Please provide image config with format for Imagebitmap");const i=d();i.width=n.width,i.height=n.height;const f=l(i);if(f!=null){const u=n.height,h=n.width;return f.drawImage(n,0,0,h,u),a=f.getImageData(0,0,h,u).data,o.height=u,o.width=h,Z(a,o)}else throw new Error("Can not access image data")}else{if(s)return new Promise((i,f)=>{const u=d(),h=l(u);if(!n||!h)return f();const w=new Image;w.crossOrigin="Anonymous",w.src=n,w.onload=()=>{u.width=w.width,u.height=w.height,h.drawImage(w,0,0,u.width,u.height);const m=h.getImageData(0,0,u.width,u.height);o.height=u.height,o.width=u.width,i(Z(m.data,o))}});throw new Error("Input data provided is not supported - aborted tensor creation")}if(a!==void 0)return Z(a,o);throw new Error("Input data provided is not supported - aborted tensor creation")},Mt=(n,t)=>{const{width:r,height:c,download:e,dispose:s}=t,a=[1,c,r,4];return new I({location:"texture",type:"float32",texture:n,dims:a,download:e,dispose:s})},Bt=(n,t)=>{const{dataType:r,dims:c,download:e,dispose:s}=t;return new I({location:"gpu-buffer",type:r??"float32",gpuBuffer:n,dims:c,download:e,dispose:s})},Dt=(n,t)=>{const{dataType:r,dims:c,download:e,dispose:s}=t;return new I({location:"ml-tensor",type:r??"float32",mlTensor:n,dims:c,download:e,dispose:s})},Lt=(n,t,r)=>new I({location:"cpu-pinned",type:n,data:t,dims:r??[t.length]}),O=new Map([["float32",Float32Array],["uint8",Uint8Array],["int8",Int8Array],["uint16",Uint16Array],["int16",Int16Array],["int32",Int32Array],["bool",Uint8Array],["float64",Float64Array],["uint32",Uint32Array],["int4",Uint8Array],["uint4",Uint8Array]]),j=new Map([[Float32Array,"float32"],[Uint8Array,"uint8"],[Int8Array,"int8"],[Uint16Array,"uint16"],[Int16Array,"int16"],[Int32Array,"int32"],[Float64Array,"float64"],[Uint32Array,"uint32"]]);let ut=!1;const _t=()=>{if(!ut){ut=!0;const n=typeof BigInt64Array<"u"&&BigInt64Array.from,t=typeof BigUint64Array<"u"&&BigUint64Array.from,r=globalThis.Float16Array,c=typeof r<"u"&&r.from;n&&(O.set("int64",BigInt64Array),j.set(BigInt64Array,"int64")),t&&(O.set("uint64",BigUint64Array),j.set(BigUint64Array,"uint64")),c?(O.set("float16",r),j.set(r,"float16")):O.set("float16",Uint16Array)}},St=n=>{let t=1;for(let r=0;r<n.length;r++){const c=n[r];if(typeof c!="number"||!Number.isSafeInteger(c))throw new TypeError(`dims[${r}] must be an integer, got: ${c}`);if(c<0)throw new RangeError(`dims[${r}] must be a non-negative integer, got: ${c}`);t*=c}return t},Ut=(n,t)=>{switch(n.location){case"cpu":return new I(n.type,n.data,t);case"cpu-pinned":return new I({location:"cpu-pinned",data:n.data,type:n.type,dims:t});case"texture":return new I({location:"texture",texture:n.texture,type:n.type,dims:t});case"gpu-buffer":return new I({location:"gpu-buffer",gpuBuffer:n.gpuBuffer,type:n.type,dims:t});case"ml-tensor":return new I({location:"ml-tensor",mlTensor:n.mlTensor,type:n.type,dims:t});default:throw new Error(`tensorReshape: tensor location ${n.location} is not supported`)}};let I=class{constructor(t,r,c){_t();let e,s;if(typeof t=="object"&&"location"in t)switch(this.dataLocation=t.location,e=t.type,s=t.dims,t.location){case"cpu-pinned":{const o=O.get(e);if(!o)throw new TypeError(`unsupported type "${e}" to create tensor from pinned buffer`);if(!(t.data instanceof o))throw new TypeError(`buffer should be of type ${o.name}`);this.cpuData=t.data;break}case"texture":{if(e!=="float32")throw new TypeError(`unsupported type "${e}" to create tensor from texture`);this.gpuTextureData=t.texture,this.downloader=t.download,this.disposer=t.dispose;break}case"gpu-buffer":{if(e!=="float32"&&e!=="float16"&&e!=="int32"&&e!=="int64"&&e!=="uint32"&&e!=="uint8"&&e!=="bool"&&e!=="uint4"&&e!=="int4")throw new TypeError(`unsupported type "${e}" to create tensor from gpu buffer`);this.gpuBufferData=t.gpuBuffer,this.downloader=t.download,this.disposer=t.dispose;break}case"ml-tensor":{if(e!=="float32"&&e!=="float16"&&e!=="int32"&&e!=="int64"&&e!=="uint32"&&e!=="uint64"&&e!=="int8"&&e!=="uint8"&&e!=="bool"&&e!=="uint4"&&e!=="int4")throw new TypeError(`unsupported type "${e}" to create tensor from MLTensor`);this.mlTensorData=t.mlTensor,this.downloader=t.download,this.disposer=t.dispose;break}default:throw new Error(`Tensor constructor: unsupported location '${this.dataLocation}'`)}else{let o,d;if(typeof t=="string")if(e=t,d=c,t==="string"){if(!Array.isArray(r))throw new TypeError("A string tensor's data must be a string array.");o=r}else{const l=O.get(t);if(l===void 0)throw new TypeError(`Unsupported tensor type: ${t}.`);if(Array.isArray(r)){if(t==="float16"&&l===Uint16Array||t==="uint4"||t==="int4")throw new TypeError(`Creating a ${t} tensor from number array is not supported. Please use ${l.name} as data.`);t==="uint64"||t==="int64"?o=l.from(r,BigInt):o=l.from(r)}else if(r instanceof l)o=r;else if(r instanceof Uint8ClampedArray)if(t==="uint8")o=Uint8Array.from(r);else throw new TypeError("A Uint8ClampedArray tensor's data must be type of uint8");else if(t==="float16"&&r instanceof Uint16Array&&l!==Uint16Array)o=new globalThis.Float16Array(r.buffer,r.byteOffset,r.length);else throw new TypeError(`A ${e} tensor's data must be type of ${l}`)}else if(d=r,Array.isArray(t)){if(t.length===0)throw new TypeError("Tensor type cannot be inferred from an empty array.");const l=typeof t[0];if(l==="string")e="string",o=t;else if(l==="boolean")e="bool",o=Uint8Array.from(t);else throw new TypeError(`Invalid element type of data array: ${l}.`)}else if(t instanceof Uint8ClampedArray)e="uint8",o=Uint8Array.from(t);else{const l=j.get(t.constructor);if(l===void 0)throw new TypeError(`Unsupported type for tensor data: ${t.constructor}.`);e=l,o=t}if(d===void 0)d=[o.length];else if(!Array.isArray(d))throw new TypeError("A tensor's dims must be a number array");s=d,this.cpuData=o,this.dataLocation="cpu"}const a=St(s);if(this.cpuData&&a!==this.cpuData.length&&!((e==="uint4"||e==="int4")&&Math.ceil(a/2)===this.cpuData.length))throw new Error(`Tensor's size(${a}) does not match data length(${this.cpuData.length}).`);this.type=e,this.dims=s,this.size=a}static async fromImage(t,r){return Pt(t,r)}static fromTexture(t,r){return Mt(t,r)}static fromGpuBuffer(t,r){return Bt(t,r)}static fromMLTensor(t,r){return Dt(t,r)}static fromPinnedBuffer(t,r,c){return Lt(t,r,c)}toDataURL(t){return Rt(this,t)}toImageData(t){return It(this,t)}get data(){if(this.ensureValid(),!this.cpuData)throw new Error("The data is not on CPU. Use `getData()` to download GPU data to CPU, or use `texture` or `gpuBuffer` property to access the GPU data directly.");return this.cpuData}get location(){return this.dataLocation}get texture(){if(this.ensureValid(),!this.gpuTextureData)throw new Error("The data is not stored as a WebGL texture.");return this.gpuTextureData}get gpuBuffer(){if(this.ensureValid(),!this.gpuBufferData)throw new Error("The data is not stored as a WebGPU buffer.");return this.gpuBufferData}get mlTensor(){if(this.ensureValid(),!this.mlTensorData)throw new Error("The data is not stored as a WebNN MLTensor.");return this.mlTensorData}async getData(t){switch(this.ensureValid(),this.dataLocation){case"cpu":case"cpu-pinned":return this.data;case"texture":case"gpu-buffer":case"ml-tensor":{if(!this.downloader)throw new Error("The current tensor is not created with a specified data downloader.");if(this.isDownloading)throw new Error("The current tensor is being downloaded.");try{this.isDownloading=!0;const r=await this.downloader();return this.downloader=void 0,this.dataLocation="cpu",this.cpuData=r,t&&this.disposer&&(this.disposer(),this.disposer=void 0),r}finally{this.isDownloading=!1}}default:throw new Error(`cannot get data from location: ${this.dataLocation}`)}}dispose(){if(this.isDownloading)throw new Error("The current tensor is being downloaded.");this.disposer&&(this.disposer(),this.disposer=void 0),this.cpuData=void 0,this.gpuTextureData=void 0,this.gpuBufferData=void 0,this.mlTensorData=void 0,this.downloader=void 0,this.isDownloading=void 0,this.dataLocation="none"}ensureValid(){if(this.dataLocation==="none")throw new Error("The tensor is disposed.")}reshape(t){if(this.ensureValid(),this.downloader||this.disposer)throw new Error("Cannot reshape a tensor that owns GPU resource.");return Ut(this,t)}};const vt=I;function Ot(n){return 1/(1+Math.exp(-n))}function Gt(n,t){return Math.hypot(n.x-t.x,n.y-t.y)}function F(n,t){const r=t.y-n.y,c=t.x-n.x;return(360-Math.atan2(r,c)*180/Math.PI)%360}function _(n,t,r){return Math.min(Math.max(n,t),r)}function Q(n){if(n===null||typeof n!="object")return!1;const t=Object.getPrototypeOf(n);return t!==null&&t!==Object.prototype&&Object.getPrototypeOf(t)!==null||Symbol.iterator in n?!1:Symbol.toStringTag in n?Object.prototype.toString.call(n)==="[object Module]":!0}function tt(n,t,r=".",c){if(!Q(t))return tt(n,{},r,c);const e=Object.assign({},t);for(const s in n){if(s==="__proto__"||s==="constructor")continue;const a=n[s];a!=null&&(c&&c(e,s,a,r)||(Array.isArray(a)&&Array.isArray(e[s])?e[s]=[...a,...e[s]]:Q(a)&&Q(e[s])?e[s]=tt(a,e[s],(r?`${r}.`:"")+s.toString(),c):e[s]=a))}return e}function Ft(n){return(...t)=>t.reduce((r,c)=>tt(r,c,"",n),{})}const Nt=Ft();let J;async function S(){if(!J){const{default:n}=await wt(async()=>{const{default:t}=await import("./opencv-D58UuVCI.js").then(r=>r.o);return{default:t}},__vite__mapDeps([0,1]));J=n instanceof Promise?await n:n}return J}async function pt(n){const t=await S();if(n instanceof t.Mat)return n.clone();const r=new Image;return r.src=n instanceof Blob?URL.createObjectURL(n):n,await r.decode(),n instanceof Blob&&URL.revokeObjectURL(r.src),t.imread(r)}function zt(n,t,r,c){const e=Math.min(r/n,c/t),s=Math.floor(n*e),a=Math.floor(t*e),o=r-s,d=c-a,l=Math.floor(o/2),i=Math.floor(d/2),f=o-l,u=d-i;return{ratio:e,size:[s,a],padding:[i,f,u,l]}}async function $t(n,t,r=10){const c=await S(),e=new c.Mat,s=new c.MatVector;c.cvtColor(n,e,c.COLOR_RGBA2GRAY),s.push_back(e);const a=256,o=[0,256],d=new c.Mat,l=new c.Mat;c.calcHist(s,[0],l,d,[a],o);const i=[d.data32F[0]];for(let p=1;p<a;p++)i[p]=i[p-1]+d.data32F[p];const f=i[a-1],u=r*f/100/2;let h=0;for(;i[h]<u;)h++;let w=a-1;for(;i[w]>=f-u;)w--;const m=255/(w-h),g=-h*m;n.convertTo(t,-1,m,g),s.delete(),e.delete(),d.delete(),l.delete()}function Ht(n,t,r,c=.5){for(let e=0;e<n.rows;e++)for(let s=0;s<n.cols;s++){const a=t.ucharPtr(e,s)[0],o=c*a/255,d=1-o,l=n.ucharPtr(e,s);for(let i=0;i<n.channels();i++)l[i]=l[i]*d+r[i]*o}}function kt({model:n,labels:t}){async function r(c,e){const s=Nt(e,{confidence:.8}),a=await S(),o=n.inputMetadata[0],d=n.outputMetadata[0],l=n.outputMetadata[1],i=await pt(c),f=i.size(),u=new a.Size(o.shape[2],o.shape[3]),h=zt(f.width,f.height,u.width,u.height),w=new a.Size(h.size[0],h.size[1]),m=h.ratio,[g,p,y,b]=h.padding,A=new a.Mat,E=new a.Mat;a.resize(i,A,w),a.copyMakeBorder(A,A,g,y,b,p,a.BORDER_CONSTANT,new a.Scalar(0,0,0,255)),a.cvtColor(A,E,a.COLOR_RGBA2BGR);const R=a.blobFromImage(E,1/255,E.size(),new a.Scalar(0,0,0),!0,!1),x=new vt("float32",R.data32F,o.shape),P=await n.run({[o.name]:x}),B=P[d.name],U=P[l.name],G=d.shape[1],M=d.shape[2],T=B.data,C=U.data,et=l.shape[1],N=new a.Size(l.shape[2],l.shape[3]),nt=N.width*N.height,ot=[];for(let W=0;W<G;W++){const D=W*M,rt=T[D+4],z=T[D+5];if(rt<s.confidence||z<0||z>=t.length)continue;const X=_(Math.floor(T[D]),0,u.width),q=_(Math.floor(T[D+1]),0,u.height),st=_(Math.ceil(T[D+2]),0,u.width),it=_(Math.ceil(T[D+3]),0,u.height),yt=T.slice(D+6,D+6+et),bt=Float32Array.from({length:nt},(K,H)=>{let k=0;for(let v=0;v<et;v++)k+=yt[v]*C[v*nt+H];return Ot(k)}),gt=new a.Rect(X,q,st-X,it-q),$=a.matFromArray(N.height,N.width,a.CV_8UC1,Uint8ClampedArray.from(bt,K=>K*255));a.resize($,$,u,0,0,a.INTER_CUBIC);const L=$.roi(gt),at=_(Math.floor((X-b)/m),0,f.width),ct=_(Math.floor((q-g)/m),0,f.height),dt=_(Math.ceil((st-b)/m),0,f.width),lt=_(Math.ceil((it-g)/m),0,f.height),At=dt-at,Tt=lt-ct;a.resize(L,L,new a.Size(At,Tt),0,0,a.INTER_CUBIC),ot.push({classId:z,label:t[z],confidence:rt,bbox:[at,ct,dt,lt],mask:Uint8ClampedArray.from({length:L.rows*L.cols},(K,H)=>{const k=Math.floor(H/L.cols),v=H%L.cols;return L.ucharPtr(k,v)[0]})}),$.delete(),L.delete()}return x.dispose(),B.dispose(),U.dispose(),i.delete(),A.delete(),E.delete(),R.delete(),ot}return{predict:r}}function V(n,t){const[r,c,e,s]=n,[a,o,d,l]=t,i=s-c,f=r-e,u=i*r+f*c,h=l-o,w=a-d,m=h*a+w*o,g=i*w-h*f;if(g===0)return;const p=(w*u-f*m)/g,y=(i*m-h*u)/g;return[p,y]}function Y(n,t,r=!1){const c=n.length;if(!(c<2))if(r){let e=0,s=0,a=0,o=0;for(const{x:w,y:m}of n)e+=w,s+=m,a+=w*m,o+=m*m;const d=(c*a-s*e)/(c*o-s*s+1e-6),l=(e-d*s)/c,i=0,f=d*0+l,u=t.height,h=d*t.height+l;return[f,i,h,u]}else{let e=0,s=0,a=0,o=0;for(const{x:w,y:m}of n)e+=w,s+=m,a+=w*m,o+=w*w;const d=(c*a-e*s)/(c*o-e*e+1e-6),l=(s-d*e)/c,i=0,f=d*0+l,u=t.width,h=d*t.width+l;return[i,f,u,h]}}async function Vt(n){const t=await S(),r=t.minAreaRect(n),c=r.center;let e=new t.Point(0,0),s=0,a=new t.Point(0,0),o=0,d=new t.Point(0,0),l=0,i=new t.Point(0,0),f=0;for(let M=0;M<n.data32S.length;M+=2){const T=new t.Point(n.data32S[M],n.data32S[M+1]),C=Gt(T,c);T.x<c.x&&T.y<c.y?C>s&&(e=T,s=C):T.x>c.x&&T.y<c.y?C>o&&(a=T,o=C):T.x<c.x&&T.y>c.y?C>l&&(d=T,l=C):T.x>c.x&&T.y>c.y&&C>f&&(i=T,f=C)}const u=F(c,a),h=F(c,e),w=F(c,d),m=F(c,i),g=[e,a],p=[d,i],y=[e,d],b=[a,i];for(let M=0;M<n.data32S.length;M+=2){const T=new t.Point(n.data32S[M],n.data32S[M+1]),C=F(c,T);C>u&&C<h?g.push(T):C>h&&C<w?y.push(T):C>w&&C<m?p.push(T):(C>m||C<u)&&b.push(T)}const A=Y(g,r.size),E=Y(p,r.size),R=Y(y,r.size,!0),x=Y(b,r.size,!0);if(!A||!E||!R||!x)return[e,a,d,i];const P=V(A,R),B=V(A,x),U=V(E,x),G=V(E,R);return!P||!B||!U||!G?[e,a,d,i]:[new t.Point(P[0],P[1]),new t.Point(B[0],B[1]),new t.Point(G[0],G[1]),new t.Point(U[0],U[1])]}async function ht(n){let t=-1,r=Number.NEGATIVE_INFINITY;const c=await S();for(let e=0;e<n.size();e++){const s=n.get(e),a=c.contourArea(s);a>r&&(r=a,t=e),s.delete()}return t}async function Yt(n,t){const r=await S(),c=new r.Mat,e=new r.Mat;r.bitwise_and(n,t,c),r.bitwise_or(n,t,e);const s=r.countNonZero(c),a=r.countNonZero(e),o=a>0?s/a:0;return c.delete(),e.delete(),o}async function jt(n,t,r,c){const e=await S(),s=new e.MatVector,a=new e.Mat,o=n.roi(r);e.cvtColor(o,o,e.COLOR_RGBA2GRAY);for(let l=0;l<o.rows;l++)for(let i=0;i<o.cols;i++)o.ucharPtr(l,i)[0]=Math.floor(o.ucharPtr(l,i)[0]*(c.ucharPtr(l,i)[0]/255));e.threshold(o,o,128,255,e.THRESH_BINARY+e.THRESH_OTSU),e.findContours(o,s,a,e.RETR_EXTERNAL,e.CHAIN_APPROX_SIMPLE);let d=await ht(s);if(d>-1){const l=s.get(d),i=new e.Mat;e.convexHull(l,i,!0,!0),s.set(d,i),l.delete();const f=e.Mat.zeros(c.rows,c.cols,e.CV_8UC1);if(e.drawContours(f,s,d,new e.Scalar(255),e.FILLED),await Yt(f,c)<.9&&(e.findContours(c,s,a,e.RETR_EXTERNAL,e.CHAIN_APPROX_SIMPLE),d=await ht(s),d>-1)){const A=s.get(d);e.convexHull(A,i,!0,!0),s.set(d,i),A.delete()}f.delete();const h=await Vt(i),w=r.height>r.width,m=w?404:640,g=w?640:404,p=e.matFromArray(4,1,e.CV_32FC2,h.flatMap(({x:A,y:E})=>[r.x+A,r.y+E])),y=e.matFromArray(4,1,e.CV_32FC2,[0,0,m,0,0,g,m,g]),b=e.getPerspectiveTransform(p,y);e.warpPerspective(n,t,b,new e.Size(m,g),e.INTER_CUBIC,e.BORDER_CONSTANT,new e.Scalar),w&&e.rotate(t,t,e.ROTATE_90_COUNTERCLOCKWISE),p.delete(),y.delete(),i.delete()}s.delete(),a.delete(),o.delete()}function mt(n){return`${(n/1e3).toFixed(2)}s`}document.addEventListener("DOMContentLoaded",async()=>{const n=document.querySelector("#note"),t=document.querySelector("#fileinput"),r=document.querySelector("#input"),c=document.querySelector("#crop"),e=document.querySelector("#output"),s=document.querySelector("#filter"),a=document.querySelector("#grayed"),o=await S(),l=await(await wt(()=>import("./ort.bundle.min-D7xVg6BR.js"),__vite__mapDeps([2,1]))).default.InferenceSession.create(xt),i=kt({model:l,labels:["kartu","ktp","ktp-fc"]});n.textContent="Ready!",t.disabled=!1;const f=[new o.Scalar(0,255,0,255),new o.Scalar(0,0,255,255),new o.Scalar(255,0,0,255)];let u=0,h=0;t.addEventListener("input",async()=>{const w=t.files?.[0];if(!w)return;u=performance.now();const m=await pt(w);o.imshow(r,m);const g=await i.predict(m);h=performance.now()-u;const p=g.find(y=>{const b=y.bbox[2]-y.bbox[0],A=y.bbox[3]-y.bbox[1],E=Math.max(b,A),R=Math.min(b,A),x=E/R;return y.classId===1&&E>100&&x>1&&x<2});if(p){const y=new o.Mat,b=new o.Rect(p.bbox[0],p.bbox[1],p.bbox[2]-p.bbox[0],p.bbox[3]-p.bbox[1]),A=o.matFromArray(b.height,b.width,o.CV_8UC1,p.mask),E=m.roi(b),R=new o.Mat,x=new o.MatVector;o.split(E,x),x.set(3,A),o.merge(x,R),o.imshow(c,R),await jt(m,y,b,A);const P=new o.Mat,B=new o.Mat;await $t(y,P,5),Ht(E,A,f[p.classId],.4),o.cvtColor(P,B,o.COLOR_RGBA2GRAY),o.rectangle(m,new o.Point(b.x,b.y),new o.Point(b.x+b.width,b.y+b.height),f[p.classId],2),o.putText(m,p.label,new o.Point(b.x+10,b.y+20),o.FONT_HERSHEY_SIMPLEX,.7,new o.Scalar(255,255,255,255),1,o.LINE_AA,!1),o.imshow(r,m),o.imshow(e,y),o.imshow(s,P),o.imshow(a,B),E.delete(),x.delete(),A.delete(),R.delete(),P.delete(),B.delete(),y.delete(),n.textContent=`Success, Time: ${mt(performance.now()-u)} (Detect: ${mt(h)})`}else{const y=o.Mat.zeros(404,640,o.CV_8UC4);o.imshow(c,y),o.imshow(e,y),o.imshow(s,y),o.imshow(a,y),y.delete(),n.textContent="Failed, Cannot find KTP in this image"}m.delete()})});
