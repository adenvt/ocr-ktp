import"./index-rQLcFmgX.js";/*!
 * ONNX Runtime Web v1.22.0
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */var We=Object.defineProperty,Er=Object.getOwnPropertyDescriptor,Tr=Object.getOwnPropertyNames,Ar=Object.prototype.hasOwnProperty,Cr=(e=>typeof require<"u"?require:typeof Proxy<"u"?new Proxy(e,{get:(t,r)=>(typeof require<"u"?require:t)[r]}):e)(function(e){if(typeof require<"u")return require.apply(this,arguments);throw Error('Dynamic require of "'+e+'" is not supported')}),b=(e,t)=>()=>(e&&(t=e(e=0)),t),Ve=(e,t)=>{for(var r in t)We(e,r,{get:t[r],enumerable:!0})},Or=(e,t,r,a)=>{if(t&&typeof t=="object"||typeof t=="function")for(let n of Tr(t))!Ar.call(e,n)&&n!==r&&We(e,n,{get:()=>t[n],enumerable:!(a=Er(t,n))||a.enumerable});return e},xt=e=>Or(We({},"__esModule",{value:!0}),e),se,z,Ee,ft,Lt,Ut=b(()=>{se=new Map,z=[],Ee=(e,t,r)=>{if(t&&typeof t.init=="function"&&typeof t.createInferenceSessionHandler=="function"){let a=se.get(e);if(a===void 0)se.set(e,{backend:t,priority:r});else{if(a.priority>r)return;if(a.priority===r&&a.backend!==t)throw new Error(`cannot register backend "${e}" using priority ${r}`)}if(r>=0){let n=z.indexOf(e);n!==-1&&z.splice(n,1);for(let i=0;i<z.length;i++)if(se.get(z[i]).priority<=r){z.splice(i,0,e);return}z.push(e)}return}throw new TypeError("not a valid backend")},ft=async e=>{let t=se.get(e);if(!t)return"backend not found.";if(t.initialized)return t.backend;if(t.aborted)return t.error;{let r=!!t.initPromise;try{return r||(t.initPromise=t.backend.init(e)),await t.initPromise,t.initialized=!0,t.backend}catch(a){return r||(t.error=`${a}`,t.aborted=!0),t.error}finally{delete t.initPromise}}},Lt=async e=>{let t=e.executionProviders||[],r=t.map(s=>typeof s=="string"?s:s.name),a=r.length===0?z:r,n,i=[],o=new Set;for(let s of a){let u=await ft(s);typeof u=="string"?i.push({name:s,err:u}):(n||(n=u),n===u&&o.add(s))}if(!n)throw new Error(`no available backend found. ERR: ${i.map(s=>`[${s.name}] ${s.err}`).join(", ")}`);for(let{name:s,err:u}of i)r.includes(s)&&console.warn(`removing requested execution provider "${s}" from session options because it is not available: ${u}`);let l=t.filter(s=>o.has(typeof s=="string"?s:s.name));return[n,new Proxy(e,{get:(s,u)=>u==="executionProviders"?l:Reflect.get(s,u)})]}}),Rr=b(()=>{Ut()}),It,xr=b(()=>{It="1.22.0"}),Oe,S,Pt=b(()=>{xr(),Oe="warning",S={wasm:{},webgl:{},webgpu:{},versions:{common:It},set logLevel(e){if(e!==void 0){if(typeof e!="string"||["verbose","info","warning","error","fatal"].indexOf(e)===-1)throw new Error(`Unsupported logging level: ${e}`);Oe=e}},get logLevel(){return Oe}},Object.defineProperty(S,"logLevel",{enumerable:!0})}),O,Lr=b(()=>{Pt(),O=S}),$t,_t,Ur=b(()=>{$t=(e,t)=>{let r=typeof document<"u"?document.createElement("canvas"):new OffscreenCanvas(1,1);r.width=e.dims[3],r.height=e.dims[2];let a=r.getContext("2d");if(a!=null){let n,i;t?.tensorLayout!==void 0&&t.tensorLayout==="NHWC"?(n=e.dims[2],i=e.dims[3]):(n=e.dims[3],i=e.dims[2]);let o=t?.format!==void 0?t.format:"RGB",l=t?.norm,s,u;l===void 0||l.mean===void 0?s=[255,255,255,255]:typeof l.mean=="number"?s=[l.mean,l.mean,l.mean,l.mean]:(s=[l.mean[0],l.mean[1],l.mean[2],0],l.mean[3]!==void 0&&(s[3]=l.mean[3])),l===void 0||l.bias===void 0?u=[0,0,0,0]:typeof l.bias=="number"?u=[l.bias,l.bias,l.bias,l.bias]:(u=[l.bias[0],l.bias[1],l.bias[2],0],l.bias[3]!==void 0&&(u[3]=l.bias[3]));let f=i*n,p=0,d=f,h=f*2,w=-1;o==="RGBA"?(p=0,d=f,h=f*2,w=f*3):o==="RGB"?(p=0,d=f,h=f*2):o==="RBG"&&(p=0,h=f,d=f*2);for(let v=0;v<i;v++)for(let C=0;C<n;C++){let y=(e.data[p++]-u[0])*s[0],c=(e.data[d++]-u[1])*s[1],m=(e.data[h++]-u[2])*s[2],E=w===-1?255:(e.data[w++]-u[3])*s[3];a.fillStyle="rgba("+y+","+c+","+m+","+E+")",a.fillRect(C,v,1,1)}if("toDataURL"in r)return r.toDataURL();throw new Error("toDataURL is not supported")}else throw new Error("Can not access image data")},_t=(e,t)=>{let r=typeof document<"u"?document.createElement("canvas").getContext("2d"):new OffscreenCanvas(1,1).getContext("2d"),a;if(r!=null){let n,i,o;t?.tensorLayout!==void 0&&t.tensorLayout==="NHWC"?(n=e.dims[2],i=e.dims[1],o=e.dims[3]):(n=e.dims[3],i=e.dims[2],o=e.dims[1]);let l=t!==void 0&&t.format!==void 0?t.format:"RGB",s=t?.norm,u,f;s===void 0||s.mean===void 0?u=[255,255,255,255]:typeof s.mean=="number"?u=[s.mean,s.mean,s.mean,s.mean]:(u=[s.mean[0],s.mean[1],s.mean[2],255],s.mean[3]!==void 0&&(u[3]=s.mean[3])),s===void 0||s.bias===void 0?f=[0,0,0,0]:typeof s.bias=="number"?f=[s.bias,s.bias,s.bias,s.bias]:(f=[s.bias[0],s.bias[1],s.bias[2],0],s.bias[3]!==void 0&&(f[3]=s.bias[3]));let p=i*n;if(t!==void 0&&(t.format!==void 0&&o===4&&t.format!=="RGBA"||o===3&&t.format!=="RGB"&&t.format!=="BGR"))throw new Error("Tensor format doesn't match input tensor dims");let d=4,h=0,w=1,v=2,C=3,y=0,c=p,m=p*2,E=-1;l==="RGBA"?(y=0,c=p,m=p*2,E=p*3):l==="RGB"?(y=0,c=p,m=p*2):l==="RBG"&&(y=0,m=p,c=p*2),a=r.createImageData(n,i);for(let U=0;U<i*n;h+=d,w+=d,v+=d,C+=d,U++)a.data[h]=(e.data[y++]-f[0])*u[0],a.data[w]=(e.data[c++]-f[1])*u[1],a.data[v]=(e.data[m++]-f[2])*u[2],a.data[C]=E===-1?255:(e.data[E++]-f[3])*u[3]}else throw new Error("Can not access image data");return a}}),we,Bt,St,Mt,Nt,kt,Ir=b(()=>{ze(),we=(e,t)=>{if(e===void 0)throw new Error("Image buffer must be defined");if(t.height===void 0||t.width===void 0)throw new Error("Image height and width must be defined");if(t.tensorLayout==="NHWC")throw new Error("NHWC Tensor layout is not supported yet");let{height:r,width:a}=t,n=t.norm??{mean:255,bias:0},i,o;typeof n.mean=="number"?i=[n.mean,n.mean,n.mean,n.mean]:i=[n.mean[0],n.mean[1],n.mean[2],n.mean[3]??255],typeof n.bias=="number"?o=[n.bias,n.bias,n.bias,n.bias]:o=[n.bias[0],n.bias[1],n.bias[2],n.bias[3]??0];let l=t.format!==void 0?t.format:"RGBA",s=t.tensorFormat!==void 0&&t.tensorFormat!==void 0?t.tensorFormat:"RGB",u=r*a,f=s==="RGBA"?new Float32Array(u*4):new Float32Array(u*3),p=4,d=0,h=1,w=2,v=3,C=0,y=u,c=u*2,m=-1;l==="RGB"&&(p=3,d=0,h=1,w=2,v=-1),s==="RGBA"?m=u*3:s==="RBG"?(C=0,c=u,y=u*2):s==="BGR"&&(c=0,y=u,C=u*2);for(let E=0;E<u;E++,d+=p,w+=p,h+=p,v+=p)f[C++]=(e[d]+o[0])/i[0],f[y++]=(e[h]+o[1])/i[1],f[c++]=(e[w]+o[2])/i[2],m!==-1&&v!==-1&&(f[m++]=(e[v]+o[3])/i[3]);return s==="RGBA"?new _("float32",f,[1,4,r,a]):new _("float32",f,[1,3,r,a])},Bt=async(e,t)=>{let r=typeof HTMLImageElement<"u"&&e instanceof HTMLImageElement,a=typeof ImageData<"u"&&e instanceof ImageData,n=typeof ImageBitmap<"u"&&e instanceof ImageBitmap,i=typeof e=="string",o,l=t??{},s=()=>{if(typeof document<"u")return document.createElement("canvas");if(typeof OffscreenCanvas<"u")return new OffscreenCanvas(1,1);throw new Error("Canvas is not supported")},u=f=>typeof HTMLCanvasElement<"u"&&f instanceof HTMLCanvasElement||f instanceof OffscreenCanvas?f.getContext("2d"):null;if(r){let f=s();f.width=e.width,f.height=e.height;let p=u(f);if(p!=null){let d=e.height,h=e.width;if(t!==void 0&&t.resizedHeight!==void 0&&t.resizedWidth!==void 0&&(d=t.resizedHeight,h=t.resizedWidth),t!==void 0){if(l=t,t.tensorFormat!==void 0)throw new Error("Image input config format must be RGBA for HTMLImageElement");l.tensorFormat="RGBA",l.height=d,l.width=h}else l.tensorFormat="RGBA",l.height=d,l.width=h;p.drawImage(e,0,0),o=p.getImageData(0,0,h,d).data}else throw new Error("Can not access image data")}else if(a){let f,p;if(t!==void 0&&t.resizedWidth!==void 0&&t.resizedHeight!==void 0?(f=t.resizedHeight,p=t.resizedWidth):(f=e.height,p=e.width),t!==void 0&&(l=t),l.format="RGBA",l.height=f,l.width=p,t!==void 0){let d=s();d.width=p,d.height=f;let h=u(d);if(h!=null)h.putImageData(e,0,0),o=h.getImageData(0,0,p,f).data;else throw new Error("Can not access image data")}else o=e.data}else if(n){if(t===void 0)throw new Error("Please provide image config with format for Imagebitmap");let f=s();f.width=e.width,f.height=e.height;let p=u(f);if(p!=null){let d=e.height,h=e.width;return p.drawImage(e,0,0,h,d),o=p.getImageData(0,0,h,d).data,l.height=d,l.width=h,we(o,l)}else throw new Error("Can not access image data")}else{if(i)return new Promise((f,p)=>{let d=s(),h=u(d);if(!e||!h)return p();let w=new Image;w.crossOrigin="Anonymous",w.src=e,w.onload=()=>{d.width=w.width,d.height=w.height,h.drawImage(w,0,0,d.width,d.height);let v=h.getImageData(0,0,d.width,d.height);l.height=d.height,l.width=d.width,f(we(v.data,l))}});throw new Error("Input data provided is not supported - aborted tensor creation")}if(o!==void 0)return we(o,l);throw new Error("Input data provided is not supported - aborted tensor creation")},St=(e,t)=>{let{width:r,height:a,download:n,dispose:i}=t,o=[1,a,r,4];return new _({location:"texture",type:"float32",texture:e,dims:o,download:n,dispose:i})},Mt=(e,t)=>{let{dataType:r,dims:a,download:n,dispose:i}=t;return new _({location:"gpu-buffer",type:r??"float32",gpuBuffer:e,dims:a,download:n,dispose:i})},Nt=(e,t)=>{let{dataType:r,dims:a,download:n,dispose:i}=t;return new _({location:"ml-tensor",type:r??"float32",mlTensor:e,dims:a,download:n,dispose:i})},kt=(e,t,r)=>new _({location:"cpu-pinned",type:e,data:t,dims:r??[t.length]})}),K,de,Re,Dt,Pr=b(()=>{K=new Map([["float32",Float32Array],["uint8",Uint8Array],["int8",Int8Array],["uint16",Uint16Array],["int16",Int16Array],["int32",Int32Array],["bool",Uint8Array],["float64",Float64Array],["uint32",Uint32Array],["int4",Uint8Array],["uint4",Uint8Array]]),de=new Map([[Float32Array,"float32"],[Uint8Array,"uint8"],[Int8Array,"int8"],[Uint16Array,"uint16"],[Int16Array,"int16"],[Int32Array,"int32"],[Float64Array,"float64"],[Uint32Array,"uint32"]]),Re=!1,Dt=()=>{if(!Re){Re=!0;let e=typeof BigInt64Array<"u"&&BigInt64Array.from,t=typeof BigUint64Array<"u"&&BigUint64Array.from,r=globalThis.Float16Array,a=typeof r<"u"&&r.from;e&&(K.set("int64",BigInt64Array),de.set(BigInt64Array,"int64")),t&&(K.set("uint64",BigUint64Array),de.set(BigUint64Array,"uint64")),a?(K.set("float16",r),de.set(r,"float16")):K.set("float16",Uint16Array)}}}),Gt,Ft,$r=b(()=>{ze(),Gt=e=>{let t=1;for(let r=0;r<e.length;r++){let a=e[r];if(typeof a!="number"||!Number.isSafeInteger(a))throw new TypeError(`dims[${r}] must be an integer, got: ${a}`);if(a<0)throw new RangeError(`dims[${r}] must be a non-negative integer, got: ${a}`);t*=a}return t},Ft=(e,t)=>{switch(e.location){case"cpu":return new _(e.type,e.data,t);case"cpu-pinned":return new _({location:"cpu-pinned",data:e.data,type:e.type,dims:t});case"texture":return new _({location:"texture",texture:e.texture,type:e.type,dims:t});case"gpu-buffer":return new _({location:"gpu-buffer",gpuBuffer:e.gpuBuffer,type:e.type,dims:t});case"ml-tensor":return new _({location:"ml-tensor",mlTensor:e.mlTensor,type:e.type,dims:t});default:throw new Error(`tensorReshape: tensor location ${e.location} is not supported`)}}}),_,ze=b(()=>{Ur(),Ir(),Pr(),$r(),_=class{constructor(e,t,r){Dt();let a,n;if(typeof e=="object"&&"location"in e)switch(this.dataLocation=e.location,a=e.type,n=e.dims,e.location){case"cpu-pinned":{let o=K.get(a);if(!o)throw new TypeError(`unsupported type "${a}" to create tensor from pinned buffer`);if(!(e.data instanceof o))throw new TypeError(`buffer should be of type ${o.name}`);this.cpuData=e.data;break}case"texture":{if(a!=="float32")throw new TypeError(`unsupported type "${a}" to create tensor from texture`);this.gpuTextureData=e.texture,this.downloader=e.download,this.disposer=e.dispose;break}case"gpu-buffer":{if(a!=="float32"&&a!=="float16"&&a!=="int32"&&a!=="int64"&&a!=="uint32"&&a!=="uint8"&&a!=="bool"&&a!=="uint4"&&a!=="int4")throw new TypeError(`unsupported type "${a}" to create tensor from gpu buffer`);this.gpuBufferData=e.gpuBuffer,this.downloader=e.download,this.disposer=e.dispose;break}case"ml-tensor":{if(a!=="float32"&&a!=="float16"&&a!=="int32"&&a!=="int64"&&a!=="uint32"&&a!=="uint64"&&a!=="int8"&&a!=="uint8"&&a!=="bool"&&a!=="uint4"&&a!=="int4")throw new TypeError(`unsupported type "${a}" to create tensor from MLTensor`);this.mlTensorData=e.mlTensor,this.downloader=e.download,this.disposer=e.dispose;break}default:throw new Error(`Tensor constructor: unsupported location '${this.dataLocation}'`)}else{let o,l;if(typeof e=="string")if(a=e,l=r,e==="string"){if(!Array.isArray(t))throw new TypeError("A string tensor's data must be a string array.");o=t}else{let s=K.get(e);if(s===void 0)throw new TypeError(`Unsupported tensor type: ${e}.`);if(Array.isArray(t)){if(e==="float16"&&s===Uint16Array||e==="uint4"||e==="int4")throw new TypeError(`Creating a ${e} tensor from number array is not supported. Please use ${s.name} as data.`);e==="uint64"||e==="int64"?o=s.from(t,BigInt):o=s.from(t)}else if(t instanceof s)o=t;else if(t instanceof Uint8ClampedArray)if(e==="uint8")o=Uint8Array.from(t);else throw new TypeError("A Uint8ClampedArray tensor's data must be type of uint8");else if(e==="float16"&&t instanceof Uint16Array&&s!==Uint16Array)o=new globalThis.Float16Array(t.buffer,t.byteOffset,t.length);else throw new TypeError(`A ${a} tensor's data must be type of ${s}`)}else if(l=t,Array.isArray(e)){if(e.length===0)throw new TypeError("Tensor type cannot be inferred from an empty array.");let s=typeof e[0];if(s==="string")a="string",o=e;else if(s==="boolean")a="bool",o=Uint8Array.from(e);else throw new TypeError(`Invalid element type of data array: ${s}.`)}else if(e instanceof Uint8ClampedArray)a="uint8",o=Uint8Array.from(e);else{let s=de.get(e.constructor);if(s===void 0)throw new TypeError(`Unsupported type for tensor data: ${e.constructor}.`);a=s,o=e}if(l===void 0)l=[o.length];else if(!Array.isArray(l))throw new TypeError("A tensor's dims must be a number array");n=l,this.cpuData=o,this.dataLocation="cpu"}let i=Gt(n);if(this.cpuData&&i!==this.cpuData.length&&!((a==="uint4"||a==="int4")&&Math.ceil(i/2)===this.cpuData.length))throw new Error(`Tensor's size(${i}) does not match data length(${this.cpuData.length}).`);this.type=a,this.dims=n,this.size=i}static async fromImage(e,t){return Bt(e,t)}static fromTexture(e,t){return St(e,t)}static fromGpuBuffer(e,t){return Mt(e,t)}static fromMLTensor(e,t){return Nt(e,t)}static fromPinnedBuffer(e,t,r){return kt(e,t,r)}toDataURL(e){return $t(this,e)}toImageData(e){return _t(this,e)}get data(){if(this.ensureValid(),!this.cpuData)throw new Error("The data is not on CPU. Use `getData()` to download GPU data to CPU, or use `texture` or `gpuBuffer` property to access the GPU data directly.");return this.cpuData}get location(){return this.dataLocation}get texture(){if(this.ensureValid(),!this.gpuTextureData)throw new Error("The data is not stored as a WebGL texture.");return this.gpuTextureData}get gpuBuffer(){if(this.ensureValid(),!this.gpuBufferData)throw new Error("The data is not stored as a WebGPU buffer.");return this.gpuBufferData}get mlTensor(){if(this.ensureValid(),!this.mlTensorData)throw new Error("The data is not stored as a WebNN MLTensor.");return this.mlTensorData}async getData(e){switch(this.ensureValid(),this.dataLocation){case"cpu":case"cpu-pinned":return this.data;case"texture":case"gpu-buffer":case"ml-tensor":{if(!this.downloader)throw new Error("The current tensor is not created with a specified data downloader.");if(this.isDownloading)throw new Error("The current tensor is being downloaded.");try{this.isDownloading=!0;let t=await this.downloader();return this.downloader=void 0,this.dataLocation="cpu",this.cpuData=t,e&&this.disposer&&(this.disposer(),this.disposer=void 0),t}finally{this.isDownloading=!1}}default:throw new Error(`cannot get data from location: ${this.dataLocation}`)}}dispose(){if(this.isDownloading)throw new Error("The current tensor is being downloaded.");this.disposer&&(this.disposer(),this.disposer=void 0),this.cpuData=void 0,this.gpuTextureData=void 0,this.gpuBufferData=void 0,this.mlTensorData=void 0,this.downloader=void 0,this.isDownloading=void 0,this.dataLocation="none"}ensureValid(){if(this.dataLocation==="none")throw new Error("The tensor is disposed.")}reshape(e){if(this.ensureValid(),this.downloader||this.disposer)throw new Error("Cannot reshape a tensor that owns GPU resource.");return Ft(this,e)}}}),k,jt=b(()=>{ze(),k=_}),Ge,xe,re,ne,Wt=b(()=>{Pt(),Ge=(e,t)=>{(typeof S.trace>"u"?!S.wasm.trace:!S.trace)||console.timeStamp(`${e}::ORT::${t}`)},xe=(e,t)=>{let r=new Error().stack?.split(/\r\n|\r|\n/g)||[],a=!1;for(let n=0;n<r.length;n++){if(a&&!r[n].includes("TRACE_FUNC")){let i=`FUNC_${e}::${r[n].trim().split(" ")[1]}`;t&&(i+=`::${t}`),Ge("CPU",i);return}r[n].includes("TRACE_FUNC")&&(a=!0)}},re=e=>{(typeof S.trace>"u"?!S.wasm.trace:!S.trace)||xe("BEGIN",e)},ne=e=>{(typeof S.trace>"u"?!S.wasm.trace:!S.trace)||xe("END",e)}}),Vt,_r=b(()=>{Ut(),jt(),Wt(),Vt=class zt{constructor(t){this.handler=t}async run(t,r,a){re();let n={},i={};if(typeof t!="object"||t===null||t instanceof k||Array.isArray(t))throw new TypeError("'feeds' must be an object that use input names as keys and OnnxValue as corresponding values.");let o=!0;if(typeof r=="object"){if(r===null)throw new TypeError("Unexpected argument[1]: cannot be null.");if(r instanceof k)throw new TypeError("'fetches' cannot be a Tensor");if(Array.isArray(r)){if(r.length===0)throw new TypeError("'fetches' cannot be an empty array.");o=!1;for(let u of r){if(typeof u!="string")throw new TypeError("'fetches' must be a string array or an object.");if(this.outputNames.indexOf(u)===-1)throw new RangeError(`'fetches' contains invalid output name: ${u}.`);n[u]=null}if(typeof a=="object"&&a!==null)i=a;else if(typeof a<"u")throw new TypeError("'options' must be an object.")}else{let u=!1,f=Object.getOwnPropertyNames(r);for(let p of this.outputNames)if(f.indexOf(p)!==-1){let d=r[p];(d===null||d instanceof k)&&(u=!0,o=!1,n[p]=d)}if(u){if(typeof a=="object"&&a!==null)i=a;else if(typeof a<"u")throw new TypeError("'options' must be an object.")}else i=r}}else if(typeof r<"u")throw new TypeError("Unexpected argument[1]: must be 'fetches' or 'options'.");for(let u of this.inputNames)if(typeof t[u]>"u")throw new Error(`input '${u}' is missing in 'feeds'.`);if(o)for(let u of this.outputNames)n[u]=null;let l=await this.handler.run(t,n,i),s={};for(let u in l)if(Object.hasOwnProperty.call(l,u)){let f=l[u];f instanceof k?s[u]=f:s[u]=new k(f.type,f.data,f.dims)}return ne(),s}async release(){return this.handler.dispose()}static async create(t,r,a,n){re();let i,o={};if(typeof t=="string"){if(i=t,typeof r=="object"&&r!==null)o=r;else if(typeof r<"u")throw new TypeError("'options' must be an object.")}else if(t instanceof Uint8Array){if(i=t,typeof r=="object"&&r!==null)o=r;else if(typeof r<"u")throw new TypeError("'options' must be an object.")}else if(t instanceof ArrayBuffer||typeof SharedArrayBuffer<"u"&&t instanceof SharedArrayBuffer){let f=t,p=0,d=t.byteLength;if(typeof r=="object"&&r!==null)o=r;else if(typeof r=="number"){if(p=r,!Number.isSafeInteger(p))throw new RangeError("'byteOffset' must be an integer.");if(p<0||p>=f.byteLength)throw new RangeError(`'byteOffset' is out of range [0, ${f.byteLength}).`);if(d=t.byteLength-p,typeof a=="number"){if(d=a,!Number.isSafeInteger(d))throw new RangeError("'byteLength' must be an integer.");if(d<=0||p+d>f.byteLength)throw new RangeError(`'byteLength' is out of range (0, ${f.byteLength-p}].`);if(typeof n=="object"&&n!==null)o=n;else if(typeof n<"u")throw new TypeError("'options' must be an object.")}else if(typeof a<"u")throw new TypeError("'byteLength' must be a number.")}else if(typeof r<"u")throw new TypeError("'options' must be an object.");i=new Uint8Array(f,p,d)}else throw new TypeError("Unexpected argument[0]: must be 'path' or 'buffer'.");let[l,s]=await Lt(o),u=await l.createInferenceSessionHandler(i,s);return ne(),new zt(u)}startProfiling(){this.handler.startProfiling()}endProfiling(){this.handler.endProfiling()}get inputNames(){return this.handler.inputNames}get outputNames(){return this.handler.outputNames}get inputMetadata(){return this.handler.inputMetadata}get outputMetadata(){return this.handler.outputMetadata}}}),Ht,Br=b(()=>{_r(),Ht=Vt}),Sr=b(()=>{}),Mr=b(()=>{}),Nr=b(()=>{}),kr=b(()=>{}),qt={};Ve(qt,{InferenceSession:()=>Ht,TRACE:()=>Ge,TRACE_FUNC_BEGIN:()=>re,TRACE_FUNC_END:()=>ne,Tensor:()=>k,env:()=>O,registerBackend:()=>Ee});var ae=b(()=>{Rr(),Lr(),Br(),jt(),Sr(),Mr(),Wt(),Nr(),kr()}),He=b(()=>{}),Zt={};Ve(Zt,{default:()=>Jt});var Le,Ue,Jt,Dr=b(()=>{or(),oe(),Ze(),Le="ort-wasm-proxy-worker",Ue=globalThis.self?.name===Le,Ue&&(self.onmessage=e=>{let{type:t,in:r}=e.data;try{switch(t){case"init-wasm":Je(r.wasm).then(()=>{et(r).then(()=>{postMessage({type:t})},a=>{postMessage({type:t,err:a})})},a=>{postMessage({type:t,err:a})});break;case"init-ep":{let{epName:a,env:n}=r;tt(n,a).then(()=>{postMessage({type:t})},i=>{postMessage({type:t,err:i})});break}case"copy-from":{let{buffer:a}=r,n=Ae(a);postMessage({type:t,out:n});break}case"create":{let{model:a,options:n}=r;rt(a,n).then(i=>{postMessage({type:t,out:i})},i=>{postMessage({type:t,err:i})});break}case"release":nt(r),postMessage({type:t});break;case"run":{let{sessionId:a,inputIndices:n,inputs:i,outputIndices:o,options:l}=r;at(a,n,i,o,new Array(o.length).fill(null),l).then(s=>{s.some(u=>u[3]!=="cpu")?postMessage({type:t,err:"Proxy does not support non-cpu tensor location."}):postMessage({type:t,out:s},it([...i,...s]))},s=>{postMessage({type:t,err:s})});break}case"end-profiling":ot(r),postMessage({type:t});break;default:}}catch(a){postMessage({type:t,err:a})}}),Jt=Ue?null:e=>new Worker(e??$,{type:"module",name:Le})}),Ie,pt,dt,$,qe,ye,ct,ht,Pe,wt,$e,Yt,_e,Kt,Ze=b(()=>{He(),Ie=typeof location>"u"?void 0:location.origin,pt=import.meta.url>"file:"&&import.meta.url<"file;",dt=()=>{{if(pt){let e=URL;return new URL(new e("ort.wasm.bundle.min.mjs",import.meta.url).href,Ie).href}return import.meta.url}},$=dt(),qe=()=>{if($&&!$.startsWith("blob:"))return $.substring(0,$.lastIndexOf("/")+1)},ye=(e,t)=>{try{let r=t??$;return(r?new URL(e,r):new URL(e)).origin===Ie}catch{return!1}},ct=(e,t)=>{let r=t??$;try{return(r?new URL(e,r):new URL(e)).href}catch{return}},ht=(e,t)=>`${t??"./"}${e}`,Pe=async e=>{let t=await(await fetch(e,{credentials:"same-origin"})).blob();return URL.createObjectURL(t)},wt=async e=>(await import(e)).default,$e=(Dr(),xt(Zt)).default,Yt=async()=>{if(!$)throw new Error("Failed to load proxy worker: cannot determine the script source URL.");if(ye($))return[void 0,$e()];let e=await Pe($);return[e,$e(e)]},_e=void 0,Kt=async(e,t,r)=>{if(!e&&!t&&_e&&$&&ye($))return[void 0,_e];{let a="ort-wasm-simd-threaded.mjs",n=e??ct(a,t),i=r&&n&&!ye(n,t),o=i?await Pe(n):n??ht(a,t);return[i?o:void 0,await wt(o)]}}}),Be,me,le,Se,yt,mt,gt,Je,A,oe=b(()=>{Ze(),me=!1,le=!1,Se=!1,yt=()=>{if(typeof SharedArrayBuffer>"u")return!1;try{return typeof MessageChannel<"u"&&new MessageChannel().port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11]))}catch{return!1}},mt=()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,30,1,28,0,65,0,253,15,253,12,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,253,186,1,26,11]))}catch{return!1}},gt=()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,5,1,96,0,1,123,3,2,1,0,10,19,1,17,0,65,1,253,15,65,2,253,15,65,3,253,15,253,147,2,11]))}catch{return!1}},Je=async e=>{if(me)return Promise.resolve();if(le)throw new Error("multiple calls to 'initializeWebAssembly()' detected.");if(Se)throw new Error("previous call to 'initializeWebAssembly()' failed.");le=!0;let t=e.initTimeout,r=e.numThreads;if(e.simd!==!1){if(e.simd==="relaxed"){if(!gt())throw new Error("Relaxed WebAssembly SIMD is not supported in the current environment.")}else if(!mt())throw new Error("WebAssembly SIMD is not supported in the current environment.")}let a=yt();r>1&&!a&&(typeof self<"u"&&!self.crossOriginIsolated&&console.warn("env.wasm.numThreads is set to "+r+", but this will not work unless you enable crossOriginIsolated mode. See https://web.dev/cross-origin-isolation-guide/ for more info."),console.warn("WebAssembly multi-threading is not supported in the current environment. Falling back to single-threading."),e.numThreads=r=1);let n=e.wasmPaths,i=typeof n=="string"?n:void 0,o=n?.mjs,l=o?.href??o,s=n?.wasm,u=s?.href??s,f=e.wasmBinary,[p,d]=await Kt(l,i,r>1),h=!1,w=[];if(t>0&&w.push(new Promise(v=>{setTimeout(()=>{h=!0,v()},t)})),w.push(new Promise((v,C)=>{let y={numThreads:r};if(f)y.wasmBinary=f;else if(u||i)y.locateFile=c=>u??i+c;else if(l&&l.indexOf("blob:")!==0)y.locateFile=c=>new URL(c,l).href;else if(p){let c=qe();c&&(y.locateFile=m=>c+m)}d(y).then(c=>{le=!1,me=!0,Be=c,v(),p&&URL.revokeObjectURL(p)},c=>{le=!1,Se=!0,C(c)})})),await Promise.race(w),h)throw new Error(`WebAssembly backend initializing failed due to timeout: ${t}ms`)},A=()=>{if(me&&Be)return Be;throw new Error("WebAssembly is not initialized yet.")}}),M,Te,T,Ye=b(()=>{oe(),M=(e,t)=>{let r=A(),a=r.lengthBytesUTF8(e)+1,n=r._malloc(a);return r.stringToUTF8(e,n,a),t.push(n),n},Te=(e,t,r,a)=>{if(typeof e=="object"&&e!==null){if(r.has(e))throw new Error("Circular reference in options");r.add(e)}Object.entries(e).forEach(([n,i])=>{let o=t?t+n:n;if(typeof i=="object")Te(i,o+".",r,a);else if(typeof i=="string"||typeof i=="number")a(o,i.toString());else if(typeof i=="boolean")a(o,i?"1":"0");else throw new Error(`Can't handle extra config type: ${typeof i}`)})},T=e=>{let t=A(),r=t.stackSave();try{let a=t.PTR_SIZE,n=t.stackAlloc(2*a);t._OrtGetLastError(n,n+a);let i=Number(t.getValue(n,a===4?"i32":"i64")),o=t.getValue(n+a,"*"),l=o?t.UTF8ToString(o):"";throw new Error(`${e} ERROR_CODE: ${i}, ERROR_MESSAGE: ${l}`)}finally{t.stackRestore(r)}}}),Xt,Gr=b(()=>{oe(),Ye(),Xt=e=>{let t=A(),r=0,a=[],n=e||{};try{if(e?.logSeverityLevel===void 0)n.logSeverityLevel=2;else if(typeof e.logSeverityLevel!="number"||!Number.isInteger(e.logSeverityLevel)||e.logSeverityLevel<0||e.logSeverityLevel>4)throw new Error(`log serverity level is not valid: ${e.logSeverityLevel}`);if(e?.logVerbosityLevel===void 0)n.logVerbosityLevel=0;else if(typeof e.logVerbosityLevel!="number"||!Number.isInteger(e.logVerbosityLevel))throw new Error(`log verbosity level is not valid: ${e.logVerbosityLevel}`);e?.terminate===void 0&&(n.terminate=!1);let i=0;return e?.tag!==void 0&&(i=M(e.tag,a)),r=t._OrtCreateRunOptions(n.logSeverityLevel,n.logVerbosityLevel,!!n.terminate,i),r===0&&T("Can't create run options."),e?.extra!==void 0&&Te(e.extra,"",new WeakSet,(o,l)=>{let s=M(o,a),u=M(l,a);t._OrtAddRunConfigEntry(r,s,u)!==0&&T(`Can't set a run config entry: ${o} - ${l}.`)}),[r,a]}catch(i){throw r!==0&&t._OrtReleaseRunOptions(r),a.forEach(o=>t._free(o)),i}}}),bt,vt,Et,ue,Tt,Qt,Fr=b(()=>{oe(),Ye(),bt=e=>{switch(e){case"disabled":return 0;case"basic":return 1;case"extended":return 2;case"all":return 99;default:throw new Error(`unsupported graph optimization level: ${e}`)}},vt=e=>{switch(e){case"sequential":return 0;case"parallel":return 1;default:throw new Error(`unsupported execution mode: ${e}`)}},Et=e=>{e.extra||(e.extra={}),e.extra.session||(e.extra.session={});let t=e.extra.session;t.use_ort_model_bytes_directly||(t.use_ort_model_bytes_directly="1"),e.executionProviders&&e.executionProviders.some(r=>(typeof r=="string"?r:r.name)==="webgpu")&&(e.enableMemPattern=!1)},ue=(e,t,r,a)=>{let n=M(t,a),i=M(r,a);A()._OrtAddSessionConfigEntry(e,n,i)!==0&&T(`Can't set a session config entry: ${t} - ${r}.`)},Tt=async(e,t,r)=>{for(let a of t){let n=typeof a=="string"?a:a.name,i=[];switch(n){case"webnn":if(n="WEBNN",typeof a!="string"){let f=a?.deviceType;f&&ue(e,"deviceType",f,r)}break;case"webgpu":if(n="JS",typeof a!="string"){let f=a;if(f?.preferredLayout){if(f.preferredLayout!=="NCHW"&&f.preferredLayout!=="NHWC")throw new Error(`preferredLayout must be either 'NCHW' or 'NHWC': ${f.preferredLayout}`);ue(e,"preferredLayout",f.preferredLayout,r)}}break;case"wasm":case"cpu":continue;default:throw new Error(`not supported execution provider: ${n}`)}let o=M(n,r),l=i.length,s=0,u=0;if(l>0){s=A()._malloc(l*A().PTR_SIZE),r.push(s),u=A()._malloc(l*A().PTR_SIZE),r.push(u);for(let f=0;f<l;f++)A().setValue(s+f*A().PTR_SIZE,i[f][0],"*"),A().setValue(u+f*A().PTR_SIZE,i[f][1],"*")}await A()._OrtAppendExecutionProvider(e,o,s,u,l)!==0&&T(`Can't append execution provider: ${n}.`)}},Qt=async e=>{let t=A(),r=0,a=[],n=e||{};Et(n);try{let i=bt(n.graphOptimizationLevel??"all"),o=vt(n.executionMode??"sequential"),l=typeof n.logId=="string"?M(n.logId,a):0,s=n.logSeverityLevel??2;if(!Number.isInteger(s)||s<0||s>4)throw new Error(`log serverity level is not valid: ${s}`);let u=n.logVerbosityLevel??0;if(!Number.isInteger(u)||u<0||u>4)throw new Error(`log verbosity level is not valid: ${u}`);let f=typeof n.optimizedModelFilePath=="string"?M(n.optimizedModelFilePath,a):0;if(r=t._OrtCreateSessionOptions(i,!!n.enableCpuMemArena,!!n.enableMemPattern,o,!!n.enableProfiling,0,l,s,u,f),r===0&&T("Can't create session options."),n.executionProviders&&await Tt(r,n.executionProviders,a),n.enableGraphCapture!==void 0){if(typeof n.enableGraphCapture!="boolean")throw new Error(`enableGraphCapture must be a boolean value: ${n.enableGraphCapture}`);ue(r,"enableGraphCapture",n.enableGraphCapture.toString(),a)}if(n.freeDimensionOverrides)for(let[p,d]of Object.entries(n.freeDimensionOverrides)){if(typeof p!="string")throw new Error(`free dimension override name must be a string: ${p}`);if(typeof d!="number"||!Number.isInteger(d)||d<0)throw new Error(`free dimension override value must be a non-negative integer: ${d}`);let h=M(p,a);t._OrtAddFreeDimensionOverride(r,h,d)!==0&&T(`Can't set a free dimension override: ${p} - ${d}.`)}return n.extra!==void 0&&Te(n.extra,"",new WeakSet,(p,d)=>{ue(r,p,d,a)}),[r,a]}catch(i){throw r!==0&&t._OrtReleaseSessionOptions(r)!==0&&T("Can't release session options."),a.forEach(o=>t._free(o)),i}}}),ee,ve,te,er,tr,Ke,Xe,rr,nr=b(()=>{ee=e=>{switch(e){case"int8":return 3;case"uint8":return 2;case"bool":return 9;case"int16":return 5;case"uint16":return 4;case"int32":return 6;case"uint32":return 12;case"float16":return 10;case"float32":return 1;case"float64":return 11;case"string":return 8;case"int64":return 7;case"uint64":return 13;case"int4":return 22;case"uint4":return 21;default:throw new Error(`unsupported data type: ${e}`)}},ve=e=>{switch(e){case 3:return"int8";case 2:return"uint8";case 9:return"bool";case 5:return"int16";case 4:return"uint16";case 6:return"int32";case 12:return"uint32";case 10:return"float16";case 1:return"float32";case 11:return"float64";case 8:return"string";case 7:return"int64";case 13:return"uint64";case 22:return"int4";case 21:return"uint4";default:throw new Error(`unsupported data type: ${e}`)}},te=(e,t)=>{let r=[-1,4,1,1,2,2,4,8,-1,1,2,8,4,8,-1,-1,-1,-1,-1,-1,-1,.5,.5][e],a=typeof t=="number"?t:t.reduce((n,i)=>n*i,1);return r>0?Math.ceil(a*r):void 0},er=e=>{switch(e){case"float16":return typeof Float16Array<"u"&&Float16Array.from?Float16Array:Uint16Array;case"float32":return Float32Array;case"uint8":return Uint8Array;case"int8":return Int8Array;case"uint16":return Uint16Array;case"int16":return Int16Array;case"int32":return Int32Array;case"bool":return Uint8Array;case"float64":return Float64Array;case"uint32":return Uint32Array;case"int64":return BigInt64Array;case"uint64":return BigUint64Array;default:throw new Error(`unsupported type: ${e}`)}},tr=e=>{switch(e){case"verbose":return 0;case"info":return 1;case"warning":return 2;case"error":return 3;case"fatal":return 4;default:throw new Error(`unsupported logging level: ${e}`)}},Ke=e=>e==="float32"||e==="float16"||e==="int32"||e==="int64"||e==="uint32"||e==="uint8"||e==="bool"||e==="uint4"||e==="int4",Xe=e=>e==="float32"||e==="float16"||e==="int32"||e==="int64"||e==="uint32"||e==="uint64"||e==="int8"||e==="uint8"||e==="bool"||e==="uint4"||e==="int4",rr=e=>{switch(e){case"none":return 0;case"cpu":return 1;case"cpu-pinned":return 2;case"texture":return 3;case"gpu-buffer":return 4;case"ml-tensor":return 5;default:throw new Error(`unsupported data location: ${e}`)}}}),Qe,ar=b(()=>{He(),Qe=async e=>{if(typeof e=="string"){let t=await fetch(e);if(!t.ok)throw new Error(`failed to load external data file: ${e}`);let r=t.headers.get("Content-Length"),a=r?parseInt(r,10):0;if(a<1073741824)return new Uint8Array(await t.arrayBuffer());{if(!t.body)throw new Error(`failed to load external data file: ${e}, no response body.`);let n=t.body.getReader(),i;try{i=new ArrayBuffer(a)}catch(l){if(l instanceof RangeError){let s=Math.ceil(a/65536);i=new WebAssembly.Memory({initial:s,maximum:s}).buffer}else throw l}let o=0;for(;;){let{done:l,value:s}=await n.read();if(l)break;let u=s.byteLength;new Uint8Array(i,o,u).set(s),o+=u}return new Uint8Array(i,0,a)}}else return e instanceof Blob?new Uint8Array(await e.arrayBuffer()):e instanceof Uint8Array?e:new Uint8Array(e)}}),At,et,tt,Z,Ct,Me,Ae,rt,nt,Ne,at,ot,it,or=b(()=>{Gr(),Fr(),nr(),oe(),Ye(),ar(),At=(e,t)=>{A()._OrtInit(e,t)!==0&&T("Can't initialize onnxruntime.")},et=async e=>{At(e.wasm.numThreads,tr(e.logLevel))},tt=async(e,t)=>{A().asyncInit?.()},Z=new Map,Ct=e=>{let t=A(),r=t.stackSave();try{let a=t.PTR_SIZE,n=t.stackAlloc(2*a);t._OrtGetInputOutputCount(e,n,n+a)!==0&&T("Can't get session input/output count.");let i=a===4?"i32":"i64";return[Number(t.getValue(n,i)),Number(t.getValue(n+a,i))]}finally{t.stackRestore(r)}},Me=(e,t)=>{let r=A(),a=r.stackSave(),n=0;try{let i=r.PTR_SIZE,o=r.stackAlloc(2*i);r._OrtGetInputOutputMetadata(e,t,o,o+i)!==0&&T("Can't get session input/output metadata.");let l=Number(r.getValue(o,"*"));n=Number(r.getValue(o+i,"*"));let s=r.HEAP32[n/4];if(s===0)return[l,0];let u=r.HEAPU32[n/4+1],f=[];for(let p=0;p<u;p++){let d=Number(r.getValue(n+8+p*i,"*"));f.push(d!==0?r.UTF8ToString(d):Number(r.getValue(n+8+(p+u)*i,"*")))}return[l,s,f]}finally{r.stackRestore(a),n!==0&&r._OrtFree(n)}},Ae=e=>{let t=A(),r=t._malloc(e.byteLength);if(r===0)throw new Error(`Can't create a session. failed to allocate a buffer of size ${e.byteLength}.`);return t.HEAPU8.set(e,r),[r,e.byteLength]},rt=async(e,t)=>{let r,a,n=A();Array.isArray(e)?[r,a]=e:e.buffer===n.HEAPU8.buffer?[r,a]=[e.byteOffset,e.byteLength]:[r,a]=Ae(e);let i=0,o=0,l=[],s=[],u=[];try{if([o,l]=await Qt(t),t?.externalData&&n.mountExternalData){let c=[];for(let m of t.externalData){let E=typeof m=="string"?m:m.path;c.push(Qe(typeof m=="string"?m:m.data).then(U=>{n.mountExternalData(E,U)}))}await Promise.all(c)}for(let c of t?.executionProviders??[])if((typeof c=="string"?c:c.name)==="webnn"){if(n.shouldTransferToMLTensor=!1,typeof c!="string"){let m=c,E=m?.context,U=m?.gpuDevice,I=m?.deviceType,q=m?.powerPreference;E?n.currentContext=E:U?n.currentContext=await n.webnnCreateMLContext(U):n.currentContext=await n.webnnCreateMLContext({deviceType:I,powerPreference:q})}else n.currentContext=await n.webnnCreateMLContext();break}i=await n._OrtCreateSession(r,a,o),n.webgpuOnCreateSession?.(i),i===0&&T("Can't create a session."),n.jsepOnCreateSession?.(),n.currentContext&&(n.webnnRegisterMLContext(i,n.currentContext),n.currentContext=void 0,n.shouldTransferToMLTensor=!0);let[f,p]=Ct(i),d=!!t?.enableGraphCapture,h=[],w=[],v=[],C=[],y=[];for(let c=0;c<f;c++){let[m,E,U]=Me(i,c);m===0&&T("Can't get an input name."),s.push(m);let I=n.UTF8ToString(m);h.push(I),v.push(E===0?{name:I,isTensor:!1}:{name:I,isTensor:!0,type:ve(E),shape:U})}for(let c=0;c<p;c++){let[m,E,U]=Me(i,c+f);m===0&&T("Can't get an output name."),u.push(m);let I=n.UTF8ToString(m);w.push(I),C.push(E===0?{name:I,isTensor:!1}:{name:I,isTensor:!0,type:ve(E),shape:U})}return Z.set(i,[i,s,u,null,d,!1]),[i,h,w,v,C]}catch(f){throw s.forEach(p=>n._OrtFree(p)),u.forEach(p=>n._OrtFree(p)),i!==0&&n._OrtReleaseSession(i)!==0&&T("Can't release session."),f}finally{n._free(r),o!==0&&n._OrtReleaseSessionOptions(o)!==0&&T("Can't release session options."),l.forEach(f=>n._free(f)),n.unmountExternalData?.()}},nt=e=>{let t=A(),r=Z.get(e);if(!r)throw new Error(`cannot release session. invalid session id: ${e}`);let[a,n,i,o,l]=r;o&&(l&&t._OrtClearBoundOutputs(o.handle)!==0&&T("Can't clear bound outputs."),t._OrtReleaseBinding(o.handle)!==0&&T("Can't release IO binding.")),t.jsepOnReleaseSession?.(e),t.webnnOnReleaseSession?.(e),t.webgpuOnReleaseSession?.(e),n.forEach(s=>t._OrtFree(s)),i.forEach(s=>t._OrtFree(s)),t._OrtReleaseSession(a)!==0&&T("Can't release session."),Z.delete(e)},Ne=async(e,t,r,a,n,i,o=!1)=>{if(!e){t.push(0);return}let l=A(),s=l.PTR_SIZE,u=e[0],f=e[1],p=e[3],d=p,h,w;if(u==="string"&&(p==="gpu-buffer"||p==="ml-tensor"))throw new Error("String tensor is not supported on GPU.");if(o&&p!=="gpu-buffer")throw new Error(`External buffer must be provided for input/output index ${i} when enableGraphCapture is true.`);if(p==="gpu-buffer"){let y=e[2].gpuBuffer;w=te(ee(u),f);{let c=l.jsepRegisterBuffer;if(!c)throw new Error('Tensor location "gpu-buffer" is not supported without using WebGPU.');h=c(a,i,y,w)}}else if(p==="ml-tensor"){let y=e[2].mlTensor;w=te(ee(u),f);let c=l.webnnRegisterMLTensor;if(!c)throw new Error('Tensor location "ml-tensor" is not supported without using WebNN.');h=c(a,y,ee(u),f)}else{let y=e[2];if(Array.isArray(y)){w=s*y.length,h=l._malloc(w),r.push(h);for(let c=0;c<y.length;c++){if(typeof y[c]!="string")throw new TypeError(`tensor data at index ${c} is not a string`);l.setValue(h+c*s,M(y[c],r),"*")}}else{let c=l.webnnIsGraphInput,m=l.webnnIsGraphOutput;if(u!=="string"&&c&&m){let E=l.UTF8ToString(n);if(c(a,E)||m(a,E)){let U=ee(u);w=te(U,f),d="ml-tensor";let I=l.webnnCreateTemporaryTensor,q=l.webnnUploadTensor;if(!I||!q)throw new Error('Tensor location "ml-tensor" is not supported without using WebNN.');let X=await I(a,U,f);q(X,new Uint8Array(y.buffer,y.byteOffset,y.byteLength)),h=X}else w=y.byteLength,h=l._malloc(w),r.push(h),l.HEAPU8.set(new Uint8Array(y.buffer,y.byteOffset,w),h)}else w=y.byteLength,h=l._malloc(w),r.push(h),l.HEAPU8.set(new Uint8Array(y.buffer,y.byteOffset,w),h)}}let v=l.stackSave(),C=l.stackAlloc(4*f.length);try{f.forEach((c,m)=>l.setValue(C+m*s,c,s===4?"i32":"i64"));let y=l._OrtCreateTensor(ee(u),h,w,C,f.length,rr(d));y===0&&T(`Can't create tensor for input/output. session=${a}, index=${i}.`),t.push(y)}finally{l.stackRestore(v)}},at=async(e,t,r,a,n,i)=>{let o=A(),l=o.PTR_SIZE,s=Z.get(e);if(!s)throw new Error(`cannot run inference. invalid session id: ${e}`);let u=s[0],f=s[1],p=s[2],d=s[3],h=s[4];s[5];let w=t.length,v=a.length,C=0,y=[],c=[],m=[],E=[],U=o.stackSave(),I=o.stackAlloc(w*l),q=o.stackAlloc(w*l),X=o.stackAlloc(v*l),st=o.stackAlloc(v*l);try{[C,y]=Xt(i);for(let g=0;g<w;g++)await Ne(r[g],c,E,e,f[t[g]],t[g],h);for(let g=0;g<v;g++)await Ne(n[g],m,E,e,p[a[g]],w+a[g],h);for(let g=0;g<w;g++)o.setValue(I+g*l,c[g],"*"),o.setValue(q+g*l,f[t[g]],"*");for(let g=0;g<v;g++)o.setValue(X+g*l,m[g],"*"),o.setValue(st+g*l,p[a[g]],"*");o.jsepOnRunStart?.(u),o.webnnOnRunStart?.(u);let N;N=await o._OrtRun(u,q,I,w,st,v,X,C),N!==0&&T("failed to call OrtRun().");let D=[],lt=[];for(let g=0;g<v;g++){let F=Number(o.getValue(X+g*l,"*"));if(F===m[g]){D.push(n[g]);continue}let mr=o.stackSave(),j=o.stackAlloc(4*l),ce=!1,x,P=0;try{o._OrtGetTensorData(F,j,j+l,j+2*l,j+3*l)!==0&&T(`Can't access output tensor data on index ${g}.`);let Ce=l===4?"i32":"i64",he=Number(o.getValue(j,Ce));P=o.getValue(j+l,"*");let ut=o.getValue(j+l*2,"*"),gr=Number(o.getValue(j+l*3,Ce)),W=[];for(let L=0;L<gr;L++)W.push(Number(o.getValue(ut+L*l,Ce)));o._OrtFree(ut)!==0&&T("Can't free memory for tensor dims.");let V=W.reduce((L,R)=>L*R,1);x=ve(he);let ie=d?.outputPreferredLocations[a[g]];if(x==="string"){if(ie==="gpu-buffer"||ie==="ml-tensor")throw new Error("String tensor is not supported on GPU.");let L=[];for(let R=0;R<V;R++){let G=o.getValue(P+R*l,"*"),br=o.getValue(P+(R+1)*l,"*"),vr=R===V-1?void 0:br-G;L.push(o.UTF8ToString(G,vr))}D.push([x,W,L,"cpu"])}else if(ie==="gpu-buffer"&&V>0){let L=o.jsepGetBuffer;if(!L)throw new Error('preferredLocation "gpu-buffer" is not supported without using WebGPU.');let R=L(P),G=te(he,V);if(G===void 0||!Ke(x))throw new Error(`Unsupported data type: ${x}`);ce=!0,D.push([x,W,{gpuBuffer:R,download:o.jsepCreateDownloader(R,G,x),dispose:()=>{o._OrtReleaseTensor(F)!==0&&T("Can't release tensor.")}},"gpu-buffer"])}else if(ie==="ml-tensor"&&V>0){let L=o.webnnEnsureTensor,R=o.webnnIsGraphInputOutputTypeSupported;if(!L||!R)throw new Error('preferredLocation "ml-tensor" is not supported without using WebNN.');if(te(he,V)===void 0||!Xe(x))throw new Error(`Unsupported data type: ${x}`);if(!R(e,x,!1))throw new Error(`preferredLocation "ml-tensor" for ${x} output is not supported by current WebNN Context.`);let G=await L(e,P,he,W,!1);ce=!0,D.push([x,W,{mlTensor:G,download:o.webnnCreateMLTensorDownloader(P,x),dispose:()=>{o.webnnReleaseTensorId(P),o._OrtReleaseTensor(F)}},"ml-tensor"])}else if(ie==="ml-tensor-cpu-output"&&V>0){let L=o.webnnCreateMLTensorDownloader(P,x)(),R=D.length;ce=!0,lt.push((async()=>{let G=[R,await L];return o.webnnReleaseTensorId(P),o._OrtReleaseTensor(F),G})()),D.push([x,W,[],"cpu"])}else{let L=er(x),R=new L(V);new Uint8Array(R.buffer,R.byteOffset,R.byteLength).set(o.HEAPU8.subarray(P,P+R.byteLength)),D.push([x,W,R,"cpu"])}}finally{o.stackRestore(mr),x==="string"&&P&&o._free(P),ce||o._OrtReleaseTensor(F)}}d&&!h&&(o._OrtClearBoundOutputs(d.handle)!==0&&T("Can't clear bound outputs."),Z.set(e,[u,f,p,d,h,!1]));for(let[g,F]of await Promise.all(lt))D[g][2]=F;return D}finally{o.webnnOnRunEnd?.(u),o.stackRestore(U),c.forEach(N=>o._OrtReleaseTensor(N)),m.forEach(N=>o._OrtReleaseTensor(N)),E.forEach(N=>o._free(N)),C!==0&&o._OrtReleaseRunOptions(C),y.forEach(N=>o._free(N))}},ot=e=>{let t=A(),r=Z.get(e);if(!r)throw new Error("invalid session id");let a=r[0],n=t._OrtEndProfiling(a);n===0&&T("Can't get an profile file name."),t._OrtFree(n)},it=e=>{let t=[];for(let r of e){let a=r[2];!Array.isArray(a)&&"buffer"in a&&t.push(a.buffer)}return t}}),H,B,Q,fe,pe,ge,ke,be,J,Y,Ot,ir,sr,lr,ur,fr,pr,dr,cr=b(()=>{ae(),or(),oe(),Ze(),H=()=>!!O.wasm.proxy&&typeof document<"u",Q=!1,fe=!1,pe=!1,be=new Map,J=(e,t)=>{let r=be.get(e);r?r.push(t):be.set(e,[t])},Y=()=>{if(Q||!fe||pe||!B)throw new Error("worker not ready")},Ot=e=>{switch(e.data.type){case"init-wasm":Q=!1,e.data.err?(pe=!0,ke[1](e.data.err)):(fe=!0,ke[0]()),ge&&(URL.revokeObjectURL(ge),ge=void 0);break;case"init-ep":case"copy-from":case"create":case"release":case"run":case"end-profiling":{let t=be.get(e.data.type);e.data.err?t.shift()[1](e.data.err):t.shift()[0](e.data.out);break}}},ir=async()=>{if(!fe){if(Q)throw new Error("multiple calls to 'initWasm()' detected.");if(pe)throw new Error("previous call to 'initWasm()' failed.");if(Q=!0,H())return new Promise((e,t)=>{B?.terminate(),Yt().then(([r,a])=>{try{B=a,B.onerror=i=>t(i),B.onmessage=Ot,ke=[e,t];let n={type:"init-wasm",in:O};if(!n.in.wasm.wasmPaths&&r){let i=qe();i&&(n.in.wasm.wasmPaths=i)}B.postMessage(n),ge=r}catch(n){t(n)}},t)});try{await Je(O.wasm),await et(O),fe=!0}catch(e){throw pe=!0,e}finally{Q=!1}}},sr=async e=>{if(H())return Y(),new Promise((t,r)=>{J("init-ep",[t,r]);let a={type:"init-ep",in:{epName:e,env:O}};B.postMessage(a)});await tt(O,e)},lr=async e=>H()?(Y(),new Promise((t,r)=>{J("copy-from",[t,r]);let a={type:"copy-from",in:{buffer:e}};B.postMessage(a,[e.buffer])})):Ae(e),ur=async(e,t)=>{if(H()){if(t?.preferredOutputLocation)throw new Error('session option "preferredOutputLocation" is not supported for proxy.');return Y(),new Promise((r,a)=>{J("create",[r,a]);let n={type:"create",in:{model:e,options:{...t}}},i=[];e instanceof Uint8Array&&i.push(e.buffer),B.postMessage(n,i)})}else return rt(e,t)},fr=async e=>{if(H())return Y(),new Promise((t,r)=>{J("release",[t,r]);let a={type:"release",in:e};B.postMessage(a)});nt(e)},pr=async(e,t,r,a,n,i)=>{if(H()){if(r.some(o=>o[3]!=="cpu"))throw new Error("input tensor on GPU is not supported for proxy.");if(n.some(o=>o))throw new Error("pre-allocated output tensor is not supported for proxy.");return Y(),new Promise((o,l)=>{J("run",[o,l]);let s=r,u={type:"run",in:{sessionId:e,inputIndices:t,inputs:s,outputIndices:a,options:i}};B.postMessage(u,it(s))})}else return at(e,t,r,a,n,i)},dr=async e=>{if(H())return Y(),new Promise((t,r)=>{J("end-profiling",[t,r]);let a={type:"end-profiling",in:e};B.postMessage(a)});ot(e)}}),De,Rt,hr,jr=b(()=>{ae(),cr(),nr(),He(),ar(),De=(e,t)=>{switch(e.location){case"cpu":return[e.type,e.dims,e.data,"cpu"];case"gpu-buffer":return[e.type,e.dims,{gpuBuffer:e.gpuBuffer},"gpu-buffer"];case"ml-tensor":return[e.type,e.dims,{mlTensor:e.mlTensor},"ml-tensor"];default:throw new Error(`invalid data location: ${e.location} for ${t()}`)}},Rt=e=>{switch(e[3]){case"cpu":return new k(e[0],e[2],e[1]);case"gpu-buffer":{let t=e[0];if(!Ke(t))throw new Error(`not supported data type: ${t} for deserializing GPU tensor`);let{gpuBuffer:r,download:a,dispose:n}=e[2];return k.fromGpuBuffer(r,{dataType:t,dims:e[1],download:a,dispose:n})}case"ml-tensor":{let t=e[0];if(!Xe(t))throw new Error(`not supported data type: ${t} for deserializing MLTensor tensor`);let{mlTensor:r,download:a,dispose:n}=e[2];return k.fromMLTensor(r,{dataType:t,dims:e[1],download:a,dispose:n})}default:throw new Error(`invalid data location: ${e[3]}`)}},hr=class{async fetchModelAndCopyToWasmMemory(e){return lr(await Qe(e))}async loadModel(e,t){re();let r;typeof e=="string"?r=await this.fetchModelAndCopyToWasmMemory(e):r=e,[this.sessionId,this.inputNames,this.outputNames,this.inputMetadata,this.outputMetadata]=await ur(r,t),ne()}async dispose(){return fr(this.sessionId)}async run(e,t,r){re();let a=[],n=[];Object.entries(e).forEach(p=>{let d=p[0],h=p[1],w=this.inputNames.indexOf(d);if(w===-1)throw new Error(`invalid input '${d}'`);a.push(h),n.push(w)});let i=[],o=[];Object.entries(t).forEach(p=>{let d=p[0],h=p[1],w=this.outputNames.indexOf(d);if(w===-1)throw new Error(`invalid output '${d}'`);i.push(h),o.push(w)});let l=a.map((p,d)=>De(p,()=>`input "${this.inputNames[n[d]]}"`)),s=i.map((p,d)=>p?De(p,()=>`output "${this.outputNames[o[d]]}"`):null),u=await pr(this.sessionId,n,l,o,s,r),f={};for(let p=0;p<u.length;p++)f[this.outputNames[o[p]]]=i[p]??Rt(u[p]);return ne(),f}startProfiling(){}endProfiling(){dr(this.sessionId)}}}),wr={};Ve(wr,{OnnxruntimeWebAssemblyBackend:()=>je,initializeFlags:()=>Fe,wasmBackend:()=>yr});var Fe,je,yr,Wr=b(()=>{ae(),cr(),jr(),Fe=()=>{(typeof O.wasm.initTimeout!="number"||O.wasm.initTimeout<0)&&(O.wasm.initTimeout=0);let e=O.wasm.simd;if(typeof e!="boolean"&&e!==void 0&&e!=="fixed"&&e!=="relaxed"&&(console.warn(`Property "env.wasm.simd" is set to unknown value "${e}". Reset it to \`false\` and ignore SIMD feature checking.`),O.wasm.simd=!1),typeof O.wasm.proxy!="boolean"&&(O.wasm.proxy=!1),typeof O.wasm.trace!="boolean"&&(O.wasm.trace=!1),typeof O.wasm.numThreads!="number"||!Number.isInteger(O.wasm.numThreads)||O.wasm.numThreads<=0)if(typeof self<"u"&&!self.crossOriginIsolated)O.wasm.numThreads=1;else{let t=typeof navigator>"u"?Cr("node:os").cpus().length:navigator.hardwareConcurrency;O.wasm.numThreads=Math.min(4,Math.ceil((t||1)/2))}},je=class{async init(e){Fe(),await ir(),await sr(e)}async createInferenceSessionHandler(e,t){let r=new hr;return await r.loadModel(e,t),r}},yr=new je});ae();ae();ae();var Vr="1.22.0",Hr=qt;{let e=(Wr(),xt(wr)).wasmBackend;Ee("cpu",e,10),Ee("wasm",e,10)}Object.defineProperty(O.versions,"web",{value:Vr,enumerable:!0});export{Ht as InferenceSession,Ge as TRACE,re as TRACE_FUNC_BEGIN,ne as TRACE_FUNC_END,k as Tensor,Hr as default,O as env,Ee as registerBackend};
