const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["assets/opencv-D58UuVCI.js","assets/index-rQLcFmgX.js","assets/ort.bundle.min-D7xVg6BR.js"])))=>i.map(i=>d[i]);
(function(){const t=document.createElement("link").relList;if(t&&t.supports&&t.supports("modulepreload"))return;for(const o of document.querySelectorAll('link[rel="modulepreload"]'))s(o);new MutationObserver(o=>{for(const r of o)if(r.type==="childList")for(const l of r.addedNodes)l.tagName==="LINK"&&l.rel==="modulepreload"&&s(l)}).observe(document,{childList:!0,subtree:!0});function a(o){const r={};return o.integrity&&(r.integrity=o.integrity),o.referrerPolicy&&(r.referrerPolicy=o.referrerPolicy),o.crossOrigin==="use-credentials"?r.credentials="include":o.crossOrigin==="anonymous"?r.credentials="omit":r.credentials="same-origin",r}function s(o){if(o.ep)return;o.ep=!0;const r=a(o);fetch(o.href,r)}})();const yt="modulepreload",pt=function(e){return"/"+e},nt={},st=function(t,a,s){let o=Promise.resolve();if(a&&a.length>0){let c=function(d){return Promise.all(d.map(u=>Promise.resolve(u).then(f=>({status:"fulfilled",value:f}),f=>({status:"rejected",reason:f}))))};var l=c;document.getElementsByTagName("link");const n=document.querySelector("meta[property=csp-nonce]"),i=n?.nonce||n?.getAttribute("nonce");o=c(a.map(d=>{if(d=pt(d),d in nt)return;nt[d]=!0;const u=d.endsWith(".css"),f=u?'[rel="stylesheet"]':"";if(document.querySelector(`link[href="${d}"]${f}`))return;const h=document.createElement("link");if(h.rel=u?"stylesheet":yt,u||(h.as="script"),h.crossOrigin="",h.href=d,i&&h.setAttribute("nonce",i),document.head.appendChild(h),u)return new Promise((b,y)=>{h.addEventListener("load",b),h.addEventListener("error",()=>y(new Error(`Unable to preload CSS for ${d}`)))})}))}function r(n){const i=new Event("vite:preloadError",{cancelable:!0});if(i.payload=n,window.dispatchEvent(i),!i.defaultPrevented)throw n}return o.then(n=>{for(const i of n||[])i.status==="rejected"&&r(i.reason);return t().catch(r)})},gt="/assets/object-detect-DKSFrVWF.onnx",bt="/assets/text-detect-Cl_XIpL2.onnx",At=(e,t)=>{const a=typeof document<"u"?document.createElement("canvas"):new OffscreenCanvas(1,1);a.width=e.dims[3],a.height=e.dims[2];const s=a.getContext("2d");if(s!=null){let o,r;t?.tensorLayout!==void 0&&t.tensorLayout==="NHWC"?(o=e.dims[2],r=e.dims[3]):(o=e.dims[3],r=e.dims[2]);const l=t?.format!==void 0?t.format:"RGB",n=t?.norm;let i,c;n===void 0||n.mean===void 0?i=[255,255,255,255]:typeof n.mean=="number"?i=[n.mean,n.mean,n.mean,n.mean]:(i=[n.mean[0],n.mean[1],n.mean[2],0],n.mean[3]!==void 0&&(i[3]=n.mean[3])),n===void 0||n.bias===void 0?c=[0,0,0,0]:typeof n.bias=="number"?c=[n.bias,n.bias,n.bias,n.bias]:(c=[n.bias[0],n.bias[1],n.bias[2],0],n.bias[3]!==void 0&&(c[3]=n.bias[3]));const d=r*o;let u=0,f=d,h=d*2,b=-1;l==="RGBA"?(u=0,f=d,h=d*2,b=d*3):l==="RGB"?(u=0,f=d,h=d*2):l==="RBG"&&(u=0,h=d,f=d*2);for(let y=0;y<r;y++)for(let p=0;p<o;p++){const w=(e.data[u++]-c[0])*i[0],m=(e.data[f++]-c[1])*i[1],g=(e.data[h++]-c[2])*i[2],A=b===-1?255:(e.data[b++]-c[3])*i[3];s.fillStyle="rgba("+w+","+m+","+g+","+A+")",s.fillRect(p,y,1,1)}if("toDataURL"in a)return a.toDataURL();throw new Error("toDataURL is not supported")}else throw new Error("Can not access image data")},Tt=(e,t)=>{const a=typeof document<"u"?document.createElement("canvas").getContext("2d"):new OffscreenCanvas(1,1).getContext("2d");let s;if(a!=null){let o,r,l;t?.tensorLayout!==void 0&&t.tensorLayout==="NHWC"?(o=e.dims[2],r=e.dims[1],l=e.dims[3]):(o=e.dims[3],r=e.dims[2],l=e.dims[1]);const n=t!==void 0&&t.format!==void 0?t.format:"RGB",i=t?.norm;let c,d;i===void 0||i.mean===void 0?c=[255,255,255,255]:typeof i.mean=="number"?c=[i.mean,i.mean,i.mean,i.mean]:(c=[i.mean[0],i.mean[1],i.mean[2],255],i.mean[3]!==void 0&&(c[3]=i.mean[3])),i===void 0||i.bias===void 0?d=[0,0,0,0]:typeof i.bias=="number"?d=[i.bias,i.bias,i.bias,i.bias]:(d=[i.bias[0],i.bias[1],i.bias[2],0],i.bias[3]!==void 0&&(d[3]=i.bias[3]));const u=r*o;if(t!==void 0&&(t.format!==void 0&&l===4&&t.format!=="RGBA"||l===3&&t.format!=="RGB"&&t.format!=="BGR"))throw new Error("Tensor format doesn't match input tensor dims");const f=4;let h=0,b=1,y=2,p=3,w=0,m=u,g=u*2,A=-1;n==="RGBA"?(w=0,m=u,g=u*2,A=u*3):n==="RGB"?(w=0,m=u,g=u*2):n==="RBG"&&(w=0,g=u,m=u*2),s=a.createImageData(o,r);for(let R=0;R<r*o;h+=f,b+=f,y+=f,p+=f,R++)s.data[h]=(e.data[w++]-d[0])*c[0],s.data[b]=(e.data[m++]-d[1])*c[1],s.data[y]=(e.data[g++]-d[2])*c[2],s.data[p]=A===-1?255:(e.data[A++]-d[3])*c[3]}else throw new Error("Can not access image data");return s},q=(e,t)=>{if(e===void 0)throw new Error("Image buffer must be defined");if(t.height===void 0||t.width===void 0)throw new Error("Image height and width must be defined");if(t.tensorLayout==="NHWC")throw new Error("NHWC Tensor layout is not supported yet");const{height:a,width:s}=t,o=t.norm??{mean:255,bias:0};let r,l;typeof o.mean=="number"?r=[o.mean,o.mean,o.mean,o.mean]:r=[o.mean[0],o.mean[1],o.mean[2],o.mean[3]??255],typeof o.bias=="number"?l=[o.bias,o.bias,o.bias,o.bias]:l=[o.bias[0],o.bias[1],o.bias[2],o.bias[3]??0];const n=t.format!==void 0?t.format:"RGBA",i=t.tensorFormat!==void 0&&t.tensorFormat!==void 0?t.tensorFormat:"RGB",c=a*s,d=i==="RGBA"?new Float32Array(c*4):new Float32Array(c*3);let u=4,f=0,h=1,b=2,y=3,p=0,w=c,m=c*2,g=-1;n==="RGB"&&(u=3,f=0,h=1,b=2,y=-1),i==="RGBA"?g=c*3:i==="RBG"?(p=0,m=c,w=c*2):i==="BGR"&&(m=0,w=c,p=c*2);for(let R=0;R<c;R++,f+=u,b+=u,h+=u,y+=u)d[p++]=(e[f]+l[0])/r[0],d[w++]=(e[h]+l[1])/r[1],d[m++]=(e[b]+l[2])/r[2],g!==-1&&y!==-1&&(d[g++]=(e[y]+l[3])/r[3]);return i==="RGBA"?new L("float32",d,[1,4,a,s]):new L("float32",d,[1,3,a,s])},xt=async(e,t)=>{const a=typeof HTMLImageElement<"u"&&e instanceof HTMLImageElement,s=typeof ImageData<"u"&&e instanceof ImageData,o=typeof ImageBitmap<"u"&&e instanceof ImageBitmap,r=typeof e=="string";let l,n=t??{};const i=()=>{if(typeof document<"u")return document.createElement("canvas");if(typeof OffscreenCanvas<"u")return new OffscreenCanvas(1,1);throw new Error("Canvas is not supported")},c=d=>typeof HTMLCanvasElement<"u"&&d instanceof HTMLCanvasElement||d instanceof OffscreenCanvas?d.getContext("2d"):null;if(a){const d=i();d.width=e.width,d.height=e.height;const u=c(d);if(u!=null){let f=e.height,h=e.width;if(t!==void 0&&t.resizedHeight!==void 0&&t.resizedWidth!==void 0&&(f=t.resizedHeight,h=t.resizedWidth),t!==void 0){if(n=t,t.tensorFormat!==void 0)throw new Error("Image input config format must be RGBA for HTMLImageElement");n.tensorFormat="RGBA",n.height=f,n.width=h}else n.tensorFormat="RGBA",n.height=f,n.width=h;u.drawImage(e,0,0),l=u.getImageData(0,0,h,f).data}else throw new Error("Can not access image data")}else if(s){let d,u;if(t!==void 0&&t.resizedWidth!==void 0&&t.resizedHeight!==void 0?(d=t.resizedHeight,u=t.resizedWidth):(d=e.height,u=e.width),t!==void 0&&(n=t),n.format="RGBA",n.height=d,n.width=u,t!==void 0){const f=i();f.width=u,f.height=d;const h=c(f);if(h!=null)h.putImageData(e,0,0),l=h.getImageData(0,0,u,d).data;else throw new Error("Can not access image data")}else l=e.data}else if(o){if(t===void 0)throw new Error("Please provide image config with format for Imagebitmap");const d=i();d.width=e.width,d.height=e.height;const u=c(d);if(u!=null){const f=e.height,h=e.width;return u.drawImage(e,0,0,h,f),l=u.getImageData(0,0,h,f).data,n.height=f,n.width=h,q(l,n)}else throw new Error("Can not access image data")}else{if(r)return new Promise((d,u)=>{const f=i(),h=c(f);if(!e||!h)return u();const b=new Image;b.crossOrigin="Anonymous",b.src=e,b.onload=()=>{f.width=b.width,f.height=b.height,h.drawImage(b,0,0,f.width,f.height);const y=h.getImageData(0,0,f.width,f.height);n.height=f.height,n.width=f.width,d(q(y.data,n))}});throw new Error("Input data provided is not supported - aborted tensor creation")}if(l!==void 0)return q(l,n);throw new Error("Input data provided is not supported - aborted tensor creation")},Rt=(e,t)=>{const{width:a,height:s,download:o,dispose:r}=t,l=[1,s,a,4];return new L({location:"texture",type:"float32",texture:e,dims:l,download:o,dispose:r})},Et=(e,t)=>{const{dataType:a,dims:s,download:o,dispose:r}=t;return new L({location:"gpu-buffer",type:a??"float32",gpuBuffer:e,dims:s,download:o,dispose:r})},Ct=(e,t)=>{const{dataType:a,dims:s,download:o,dispose:r}=t;return new L({location:"ml-tensor",type:a??"float32",mlTensor:e,dims:s,download:o,dispose:r})},Mt=(e,t,a)=>new L({location:"cpu-pinned",type:e,data:t,dims:a??[t.length]}),k=new Map([["float32",Float32Array],["uint8",Uint8Array],["int8",Int8Array],["uint16",Uint16Array],["int16",Int16Array],["int32",Int32Array],["bool",Uint8Array],["float64",Float64Array],["uint32",Uint32Array],["int4",Uint8Array],["uint4",Uint8Array]]),X=new Map([[Float32Array,"float32"],[Uint8Array,"uint8"],[Int8Array,"int8"],[Uint16Array,"uint16"],[Int16Array,"int16"],[Int32Array,"int32"],[Float64Array,"float64"],[Uint32Array,"uint32"]]);let ot=!1;const It=()=>{if(!ot){ot=!0;const e=typeof BigInt64Array<"u"&&BigInt64Array.from,t=typeof BigUint64Array<"u"&&BigUint64Array.from,a=globalThis.Float16Array,s=typeof a<"u"&&a.from;e&&(k.set("int64",BigInt64Array),X.set(BigInt64Array,"int64")),t&&(k.set("uint64",BigUint64Array),X.set(BigUint64Array,"uint64")),s?(k.set("float16",a),X.set(a,"float16")):k.set("float16",Uint16Array)}},Pt=e=>{let t=1;for(let a=0;a<e.length;a++){const s=e[a];if(typeof s!="number"||!Number.isSafeInteger(s))throw new TypeError(`dims[${a}] must be an integer, got: ${s}`);if(s<0)throw new RangeError(`dims[${a}] must be a non-negative integer, got: ${s}`);t*=s}return t},Bt=(e,t)=>{switch(e.location){case"cpu":return new L(e.type,e.data,t);case"cpu-pinned":return new L({location:"cpu-pinned",data:e.data,type:e.type,dims:t});case"texture":return new L({location:"texture",texture:e.texture,type:e.type,dims:t});case"gpu-buffer":return new L({location:"gpu-buffer",gpuBuffer:e.gpuBuffer,type:e.type,dims:t});case"ml-tensor":return new L({location:"ml-tensor",mlTensor:e.mlTensor,type:e.type,dims:t});default:throw new Error(`tensorReshape: tensor location ${e.location} is not supported`)}};let L=class{constructor(t,a,s){It();let o,r;if(typeof t=="object"&&"location"in t)switch(this.dataLocation=t.location,o=t.type,r=t.dims,t.location){case"cpu-pinned":{const n=k.get(o);if(!n)throw new TypeError(`unsupported type "${o}" to create tensor from pinned buffer`);if(!(t.data instanceof n))throw new TypeError(`buffer should be of type ${n.name}`);this.cpuData=t.data;break}case"texture":{if(o!=="float32")throw new TypeError(`unsupported type "${o}" to create tensor from texture`);this.gpuTextureData=t.texture,this.downloader=t.download,this.disposer=t.dispose;break}case"gpu-buffer":{if(o!=="float32"&&o!=="float16"&&o!=="int32"&&o!=="int64"&&o!=="uint32"&&o!=="uint8"&&o!=="bool"&&o!=="uint4"&&o!=="int4")throw new TypeError(`unsupported type "${o}" to create tensor from gpu buffer`);this.gpuBufferData=t.gpuBuffer,this.downloader=t.download,this.disposer=t.dispose;break}case"ml-tensor":{if(o!=="float32"&&o!=="float16"&&o!=="int32"&&o!=="int64"&&o!=="uint32"&&o!=="uint64"&&o!=="int8"&&o!=="uint8"&&o!=="bool"&&o!=="uint4"&&o!=="int4")throw new TypeError(`unsupported type "${o}" to create tensor from MLTensor`);this.mlTensorData=t.mlTensor,this.downloader=t.download,this.disposer=t.dispose;break}default:throw new Error(`Tensor constructor: unsupported location '${this.dataLocation}'`)}else{let n,i;if(typeof t=="string")if(o=t,i=s,t==="string"){if(!Array.isArray(a))throw new TypeError("A string tensor's data must be a string array.");n=a}else{const c=k.get(t);if(c===void 0)throw new TypeError(`Unsupported tensor type: ${t}.`);if(Array.isArray(a)){if(t==="float16"&&c===Uint16Array||t==="uint4"||t==="int4")throw new TypeError(`Creating a ${t} tensor from number array is not supported. Please use ${c.name} as data.`);t==="uint64"||t==="int64"?n=c.from(a,BigInt):n=c.from(a)}else if(a instanceof c)n=a;else if(a instanceof Uint8ClampedArray)if(t==="uint8")n=Uint8Array.from(a);else throw new TypeError("A Uint8ClampedArray tensor's data must be type of uint8");else if(t==="float16"&&a instanceof Uint16Array&&c!==Uint16Array)n=new globalThis.Float16Array(a.buffer,a.byteOffset,a.length);else throw new TypeError(`A ${o} tensor's data must be type of ${c}`)}else if(i=a,Array.isArray(t)){if(t.length===0)throw new TypeError("Tensor type cannot be inferred from an empty array.");const c=typeof t[0];if(c==="string")o="string",n=t;else if(c==="boolean")o="bool",n=Uint8Array.from(t);else throw new TypeError(`Invalid element type of data array: ${c}.`)}else if(t instanceof Uint8ClampedArray)o="uint8",n=Uint8Array.from(t);else{const c=X.get(t.constructor);if(c===void 0)throw new TypeError(`Unsupported type for tensor data: ${t.constructor}.`);o=c,n=t}if(i===void 0)i=[n.length];else if(!Array.isArray(i))throw new TypeError("A tensor's dims must be a number array");r=i,this.cpuData=n,this.dataLocation="cpu"}const l=Pt(r);if(this.cpuData&&l!==this.cpuData.length&&!((o==="uint4"||o==="int4")&&Math.ceil(l/2)===this.cpuData.length))throw new Error(`Tensor's size(${l}) does not match data length(${this.cpuData.length}).`);this.type=o,this.dims=r,this.size=l}static async fromImage(t,a){return xt(t,a)}static fromTexture(t,a){return Rt(t,a)}static fromGpuBuffer(t,a){return Et(t,a)}static fromMLTensor(t,a){return Ct(t,a)}static fromPinnedBuffer(t,a,s){return Mt(t,a,s)}toDataURL(t){return At(this,t)}toImageData(t){return Tt(this,t)}get data(){if(this.ensureValid(),!this.cpuData)throw new Error("The data is not on CPU. Use `getData()` to download GPU data to CPU, or use `texture` or `gpuBuffer` property to access the GPU data directly.");return this.cpuData}get location(){return this.dataLocation}get texture(){if(this.ensureValid(),!this.gpuTextureData)throw new Error("The data is not stored as a WebGL texture.");return this.gpuTextureData}get gpuBuffer(){if(this.ensureValid(),!this.gpuBufferData)throw new Error("The data is not stored as a WebGPU buffer.");return this.gpuBufferData}get mlTensor(){if(this.ensureValid(),!this.mlTensorData)throw new Error("The data is not stored as a WebNN MLTensor.");return this.mlTensorData}async getData(t){switch(this.ensureValid(),this.dataLocation){case"cpu":case"cpu-pinned":return this.data;case"texture":case"gpu-buffer":case"ml-tensor":{if(!this.downloader)throw new Error("The current tensor is not created with a specified data downloader.");if(this.isDownloading)throw new Error("The current tensor is being downloaded.");try{this.isDownloading=!0;const a=await this.downloader();return this.downloader=void 0,this.dataLocation="cpu",this.cpuData=a,t&&this.disposer&&(this.disposer(),this.disposer=void 0),a}finally{this.isDownloading=!1}}default:throw new Error(`cannot get data from location: ${this.dataLocation}`)}}dispose(){if(this.isDownloading)throw new Error("The current tensor is being downloaded.");this.disposer&&(this.disposer(),this.disposer=void 0),this.cpuData=void 0,this.gpuTextureData=void 0,this.gpuBufferData=void 0,this.mlTensorData=void 0,this.downloader=void 0,this.isDownloading=void 0,this.dataLocation="none"}ensureValid(){if(this.dataLocation==="none")throw new Error("The tensor is disposed.")}reshape(t){if(this.ensureValid(),this.downloader||this.disposer)throw new Error("Cannot reshape a tensor that owns GPU resource.");return Bt(this,t)}};const it=L;function ct(e){return 1/(1+Math.exp(-e))}function Dt(e,t){return Math.hypot(e.x-t.x,e.y-t.y)}function z(e,t){const a=t.y-e.y,s=t.x-e.x;return(360-Math.atan2(a,s)*180/Math.PI)%360}function v(e,t,a){return Math.min(Math.max(e,t),a)}function K(e){if(e===null||typeof e!="object")return!1;const t=Object.getPrototypeOf(e);return t!==null&&t!==Object.prototype&&Object.getPrototypeOf(t)!==null||Symbol.iterator in e?!1:Symbol.toStringTag in e?Object.prototype.toString.call(e)==="[object Module]":!0}function J(e,t,a=".",s){if(!K(t))return J(e,{},a,s);const o=Object.assign({},t);for(const r in e){if(r==="__proto__"||r==="constructor")continue;const l=e[r];l!=null&&(s&&s(o,r,l,a)||(Array.isArray(l)&&Array.isArray(o[r])?o[r]=[...l,...o[r]]:K(l)&&K(o[r])?o[r]=J(l,o[r],(a?`${a}.`:"")+r.toString(),s):o[r]=l))}return o}function _t(e){return(...t)=>t.reduce((a,s)=>J(a,s,"",e),{})}const dt=_t();let Z;async function B(){if(!Z){const{default:e}=await st(async()=>{const{default:t}=await import("./opencv-D58UuVCI.js").then(a=>a.o);return{default:t}},__vite__mapDeps([0,1]));Z=e instanceof Promise?await e:e}return Z}async function Q(e){const t=await B();if(e instanceof t.Mat)return e.clone();const a=new Image;return a.src=e instanceof Blob?URL.createObjectURL(e):e,await a.decode(),e instanceof Blob&&URL.revokeObjectURL(a.src),t.imread(a)}async function vt(e,t,a=10){const s=await B(),o=new s.Mat,r=new s.MatVector;s.cvtColor(e,o,s.COLOR_RGBA2GRAY),r.push_back(o);const l=256,n=[0,256],i=new s.Mat,c=new s.Mat;s.calcHist(r,[0],c,i,[l],n);const d=[i.data32F[0]];for(let w=1;w<l;w++)d[w]=d[w-1]+i.data32F[w];const u=d[l-1],f=a*u/100/2;let h=0;for(;d[h]<f;)h++;let b=l-1;for(;d[b]>=u-f;)b--;const y=255/(b-h),p=-h*y;e.convertTo(t,-1,y,p),r.delete(),o.delete(),i.delete(),c.delete()}function Lt(e,t,a,s=.5){for(let o=0;o<e.rows;o++)for(let r=0;r<e.cols;r++){const l=t.ucharPtr(o,r)[0],n=s*l/255,i=1-n,c=e.ucharPtr(o,r);for(let d=0;d<e.channels();d++)c[d]=c[d]*i+a[d]*n}}function lt(e,t,a=5){const s=Math.min(t.width/e.width,t.height/e.height),o=Math.floor(e.width*s),r=Math.floor(e.height*s),l=t.width-o,n=t.height-r;let i=0,c=0;a&1?i=Math.floor(l/2):a&2&&(i=l),a&4?c=Math.floor(n/2):a&8&&(c=n);async function d(p,w,m,g){const A=await B();A.resize(p,w,new A.Size(o,r),0,0,g??A.INTER_CUBIC),A.copyMakeBorder(w,w,c,n-c,i,l-i,A.BORDER_CONSTANT,m??new A.Scalar(0,0,0,255))}async function u(p){const w=await B(),m=await f(new w.Point(p.x,p.y)),g=await f(new w.Point(p.x+p.width,p.y+p.height),!0);return new w.Rect(v(m.x,0,o),v(m.y,0,r),v(g.x-m.x,0,o),v(g.y-m.y,0,r))}async function f(p,w=!1){const m=await B(),g=w?Math.ceil(p.x*s):Math.floor(p.x*s),A=w?Math.ceil(p.y*s):Math.floor(p.y*s);return new m.Point(v(g,0,o),v(A,0,r))}async function h(p,w,m){const g=await B(),A=new g.Rect(i,c,o,r),R=p.roi(A);g.resize(R,w,e,0,0,m??g.INTER_CUBIC),R.delete()}async function b(p){const w=await B(),m=await y(new w.Point(p.x,p.y)),g=await y(new w.Point(p.x+p.width,p.y+p.height),!0);return new w.Rect(m.x,m.y,g.x-m.x,g.y-m.y)}async function y(p,w=!1){const m=await B(),g=w?Math.ceil((p.x-i)/s):Math.floor((p.x-i)/s),A=w?Math.ceil((p.y-c)/s):Math.floor((p.y-c)/s);return new m.Point(v(g,0,e.width),v(A,0,e.height))}return{scaleMat:d,scaleRect:u,scalePoint:f,revertMat:h,revertRect:b,revertPoint:y}}function Ot({model:e,labels:t}){const a=e.inputMetadata[0],s=e.outputMetadata[0],o=e.outputMetadata[1];async function r(l,n){const i=dt(n,{confidence:.8}),c=await B(),d=await Q(l),u=d.size(),f=new c.Size(a.shape[2],a.shape[3]),h=lt(u,f),b=new c.Mat,y=new c.Mat;await h.scaleMat(d,b),c.cvtColor(b,y,c.COLOR_RGBA2BGR);const p=c.blobFromImage(y,1/255,y.size(),new c.Scalar(0,0,0),!0,!1),w=new it("float32",p.data32F,a.shape),m=await e.run({[a.name]:w}),g=m[s.name],A=m[o.name],R=s.shape[1],I=s.shape[2],E=g.data,P=A.data,C=o.shape[1],_=new c.Size(o.shape[2],o.shape[3]),D=_.width*_.height,M=[];for(let T=0;T<R;T++){const x=T*I,$=E[x+4],O=E[x+5];if($<i.confidence||O<0||O>=t.length)continue;const tt=v(Math.floor(E[x]),0,f.width),et=v(Math.floor(E[x+1]),0,f.height),ut=v(Math.ceil(E[x+2]),0,f.width),ft=v(Math.ceil(E[x+3]),0,f.height),ht=E.slice(x+6,x+6+C),wt=Float32Array.from({length:D},(W,H)=>{let V=0;for(let F=0;F<C;F++)V+=ht[F]*P[F*D+H];return ct(V)}),mt=new c.Rect(tt,et,ut-tt,ft-et),G=c.matFromArray(_.height,_.width,c.CV_8UC1,Uint8ClampedArray.from(wt,W=>W*255));c.resize(G,G,f,0,0,c.INTER_CUBIC),await h.revertMat(G,G);const U=await h.revertRect(mt),N=G.roi(U);M.push({classId:O,label:t[O],confidence:$,bbox:[U.x,U.y,U.x+U.width,U.y+U.height],mask:Uint8ClampedArray.from({length:N.rows*N.cols},(W,H)=>{const V=Math.floor(H/N.cols),F=H%N.cols;return N.ucharPtr(V,F)[0]})}),G.delete(),N.delete()}return w.dispose(),g.dispose(),A.dispose(),d.delete(),b.delete(),y.delete(),p.delete(),M}return{predict:r}}function Y(e,t){const[a,s,o,r]=e,[l,n,i,c]=t,d=r-s,u=a-o,f=d*a+u*s,h=c-n,b=l-i,y=h*l+b*n,p=d*b-h*u;if(p===0)return;const w=(b*f-u*y)/p,m=(d*y-h*f)/p;return[w,m]}function j(e,t,a=!1){const s=e.length;if(!(s<2))if(a){let o=0,r=0,l=0,n=0;for(const{x:b,y}of e)o+=b,r+=y,l+=b*y,n+=y*y;const i=(s*l-r*o)/(s*n-r*r+1e-6),c=(o-i*r)/s,d=0,u=i*0+c,f=t.height,h=i*t.height+c;return[u,d,h,f]}else{let o=0,r=0,l=0,n=0;for(const{x:b,y}of e)o+=b,r+=y,l+=b*y,n+=b*b;const i=(s*l-o*r)/(s*n-o*o+1e-6),c=(r-i*o)/s,d=0,u=i*0+c,f=t.width,h=i*t.width+c;return[d,u,f,h]}}async function Ut(e){const t=await B(),a=t.minAreaRect(e),s=a.center;let o=new t.Point(0,0),r=0,l=new t.Point(0,0),n=0,i=new t.Point(0,0),c=0,d=new t.Point(0,0),u=0;for(let M=0;M<e.data32S.length;M+=2){const T=new t.Point(e.data32S[M],e.data32S[M+1]),x=Dt(T,s);T.x<s.x&&T.y<s.y?x>r&&(o=T,r=x):T.x>s.x&&T.y<s.y?x>n&&(l=T,n=x):T.x<s.x&&T.y>s.y?x>c&&(i=T,c=x):T.x>s.x&&T.y>s.y&&x>u&&(d=T,u=x)}const f=z(s,l),h=z(s,o),b=z(s,i),y=z(s,d),p=[o,l],w=[i,d],m=[o,i],g=[l,d];for(let M=0;M<e.data32S.length;M+=2){const T=new t.Point(e.data32S[M],e.data32S[M+1]),x=z(s,T);x>f&&x<h?p.push(T):x>h&&x<b?m.push(T):x>b&&x<y?w.push(T):(x>y||x<f)&&g.push(T)}const A=j(p,a.size),R=j(w,a.size),I=j(m,a.size,!0),E=j(g,a.size,!0);if(!A||!R||!I||!E)return[o,l,i,d];const P=Y(A,I),C=Y(A,E),_=Y(R,E),D=Y(R,I);return!P||!C||!_||!D?[o,l,i,d]:[new t.Point(P[0],P[1]),new t.Point(C[0],C[1]),new t.Point(D[0],D[1]),new t.Point(_[0],_[1])]}async function rt(e){let t=-1,a=Number.NEGATIVE_INFINITY;const s=await B();for(let o=0;o<e.size();o++){const r=e.get(o),l=s.contourArea(r);l>a&&(a=l,t=o),r.delete()}return t}async function St(e,t){const a=await B(),s=new a.Mat,o=new a.Mat;a.bitwise_and(e,t,s),a.bitwise_or(e,t,o);const r=a.countNonZero(s),l=a.countNonZero(o),n=l>0?r/l:0;return s.delete(),o.delete(),n}async function Gt(e,t,a,s,o){const r=await B(),l=new r.MatVector,n=new r.Mat,i=e.roi(a);r.cvtColor(i,i,r.COLOR_RGBA2GRAY);for(let d=0;d<i.rows;d++)for(let u=0;u<i.cols;u++)i.ucharPtr(d,u)[0]=Math.floor(i.ucharPtr(d,u)[0]*(s.ucharPtr(d,u)[0]/255));r.threshold(i,i,128,255,r.THRESH_BINARY+r.THRESH_OTSU),r.findContours(i,l,n,r.RETR_EXTERNAL,r.CHAIN_APPROX_SIMPLE);let c=await rt(l);if(c>-1){const d=l.get(c),u=new r.Mat;r.convexHull(d,u,!0,!0),l.set(c,u),d.delete();const f=r.Mat.zeros(s.rows,s.cols,r.CV_8UC1);if(r.drawContours(f,l,c,new r.Scalar(255),r.FILLED),await St(f,s)<.9&&(r.findContours(s,l,n,r.RETR_EXTERNAL,r.CHAIN_APPROX_SIMPLE),c=await rt(l),c>-1)){const R=l.get(c);r.convexHull(R,u,!0,!0),l.set(c,u),R.delete()}f.delete();const b=await Ut(u),y=a.height>a.width,p=y?o.height:o.width,w=y?o.width:o.height,m=r.matFromArray(4,1,r.CV_32FC2,b.flatMap(({x:R,y:I})=>[a.x+R,a.y+I])),g=r.matFromArray(4,1,r.CV_32FC2,[0,0,p,0,0,w,p,w]),A=r.getPerspectiveTransform(m,g);r.warpPerspective(e,t,A,new r.Size(p,w),r.INTER_CUBIC,r.BORDER_CONSTANT,new r.Scalar),y&&r.rotate(t,t,r.ROTATE_90_COUNTERCLOCKWISE),m.delete(),g.delete(),u.delete()}l.delete(),n.delete(),i.delete()}function Nt({model:e}){const t=e.inputMetadata[0],a=e.outputMetadata[0];async function s(o,r){const l=dt(r,{confidence:.3,unclipRatio:2,boxMinArea:64}),n=await B(),i=await Q(o),c=i.size(),d=new n.Size(t.shape[2],t.shape[3]),u=lt(c,d),f=new n.Mat,h=new n.Mat;await u.scaleMat(i,f),n.cvtColor(f,h,n.COLOR_RGBA2BGR);const b=n.blobFromImage(h,1/255,h.size(),new n.Scalar(0,0,0),!0,!1),y=new it("float32",b.data32F,[1,...t.shape.slice(1)]),w=(await e.run({[t.name]:y}))[a.name],m=w.data,g=n.matFromArray(a.shape[2],a.shape[3],n.CV_8UC1,Uint8ClampedArray.from(m,E=>ct(E)>=l.confidence?255:0)),A=new n.MatVector,R=new n.Mat;n.findContours(g,A,R,n.RETR_EXTERNAL,n.CHAIN_APPROX_SIMPLE);const I=[];for(let E=0;E<A.size();E++){const P=A.get(E),C=n.contourArea(P),_=n.arcLength(P,!0);if(C>l.boxMinArea&&_>0){const D=Math.ceil(C*l.unclipRatio/_),M=n.boundingRect(P),T=await u.revertRect(new n.Rect(M.x-D,M.y-D,M.width+D*2,M.height+D*2));I.push([T.x,T.y,T.x+T.width,T.y+T.height])}P.delete()}return y.dispose(),w.dispose(),g.delete(),b.delete(),f.delete(),h.delete(),i.delete(),I}return{predict:s}}function at(e){return`${(e/1e3).toFixed(2)}s`}function S(e){document.querySelector("#note").textContent=e}async function Ft(){const e=document.querySelector("#fileinput"),t=document.querySelector("#input"),a=document.querySelector("#crop"),s=document.querySelector("#output"),o=document.querySelector("#filter"),r=document.querySelector("#grayed"),l=document.querySelector("#text-mask");S("Initiating OpenCV ...");const n=await B();S("Initiating ONNX Runtime ...");const i=await st(()=>import("./ort.bundle.min-D7xVg6BR.js"),__vite__mapDeps([2,1]));S("Initiating YOLO Model ...");const c=Ot({model:await i.default.InferenceSession.create(gt),labels:["kartu","ktp","ktp-fc"]});e.disabled=!1;const d=Nt({model:await i.InferenceSession.create(bt)});S("Ready!");const u=[new n.Scalar(0,255,0,255),new n.Scalar(0,0,255,255),new n.Scalar(255,0,0,255)];let f=0,h=0;e.addEventListener("input",async()=>{const b=e.files?.[0];if(!b)return;f=performance.now();const y=await Q(b);n.imshow(t,y);const p=await c.predict(y);h=performance.now()-f;const w=p.find(m=>{const g=m.bbox[2]-m.bbox[0],A=m.bbox[3]-m.bbox[1],R=Math.max(g,A),I=Math.min(g,A),E=R/I;return m.classId===1&&R>100&&E>1&&E<2});if(w){const m=new n.Mat,g=new n.Rect(w.bbox[0],w.bbox[1],w.bbox[2]-w.bbox[0],w.bbox[3]-w.bbox[1]),A=n.matFromArray(g.height,g.width,n.CV_8UC1,w.mask),R=y.roi(g),I=new n.Mat,E=new n.MatVector;n.split(R,E),E.set(3,A),n.merge(E,I),n.imshow(a,I),await Gt(y,m,g,A,new n.Size(1024,646));const P=new n.Mat,C=new n.Mat;await vt(m,P,5),Lt(R,A,u[w.classId],.4),n.cvtColor(P,C,n.COLOR_RGBA2GRAY),n.cvtColor(C,C,n.COLOR_GRAY2RGBA),n.rectangle(y,new n.Point(g.x,g.y),new n.Point(g.x+g.width,g.y+g.height),u[w.classId],2),n.putText(y,w.label,new n.Point(g.x+10,g.y+20),n.FONT_HERSHEY_SIMPLEX,.7,new n.Scalar(255,255,255,255),1,n.LINE_AA,!1);const _=await d.predict(C),D=new n.Mat(C.rows,C.cols,m.type(),new n.Scalar(255,255,255,255));for(const T of _){const x=new n.Rect(T[0],T[1],T[2]-T[0],T[3]-T[1]),$=C.roi(x),O=D.roi(x);$.copyTo(O),$.delete(),O.delete()}n.imshow(t,y),n.imshow(s,m),n.imshow(o,P),n.imshow(r,C),n.imshow(l,D),R.delete(),E.delete(),A.delete(),I.delete();const M=performance.now()-f;S(`Success, Time: ${at(M)} (Detect: ${at(h)})`),P.delete(),C.delete(),m.delete()}else{const m=n.Mat.zeros(404,640,n.CV_8UC4);n.imshow(a,m),n.imshow(s,m),n.imshow(o,m),n.imshow(r,m),m.delete(),S("Failed, Cannot find KTP in this image")}y.delete()})}document.addEventListener("DOMContentLoaded",()=>{Ft().catch(e=>{const t=e instanceof Error?e.message:e;S(`Error, ${t}`)})});
