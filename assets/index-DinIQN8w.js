const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["assets/opencv-Cg6dp1wg.js","assets/index-rQLcFmgX.js","assets/ort.bundle.min-D7xVg6BR.js"])))=>i.map(i=>d[i]);
(function(){const t=document.createElement("link").relList;if(t&&t.supports&&t.supports("modulepreload"))return;for(const n of document.querySelectorAll('link[rel="modulepreload"]'))i(n);new MutationObserver(n=>{for(const a of n)if(a.type==="childList")for(const l of a.addedNodes)l.tagName==="LINK"&&l.rel==="modulepreload"&&i(l)}).observe(document,{childList:!0,subtree:!0});function r(n){const a={};return n.integrity&&(a.integrity=n.integrity),n.referrerPolicy&&(a.referrerPolicy=n.referrerPolicy),n.crossOrigin==="use-credentials"?a.credentials="include":n.crossOrigin==="anonymous"?a.credentials="omit":a.credentials="same-origin",a}function i(n){if(n.ep)return;n.ep=!0;const a=r(n);fetch(n.href,a)}})();const bt="modulepreload",Tt=function(e){return"/"+e},lt={},ht=function(t,r,i){let n=Promise.resolve();if(r&&r.length>0){let c=function(d){return Promise.all(d.map(u=>Promise.resolve(u).then(f=>({status:"fulfilled",value:f}),f=>({status:"rejected",reason:f}))))};var l=c;document.getElementsByTagName("link");const s=document.querySelector("meta[property=csp-nonce]"),o=s?.nonce||s?.getAttribute("nonce");n=c(r.map(d=>{if(d=Tt(d),d in lt)return;lt[d]=!0;const u=d.endsWith(".css"),f=u?'[rel="stylesheet"]':"";if(document.querySelector(`link[href="${d}"]${f}`))return;const h=document.createElement("link");if(h.rel=u?"stylesheet":bt,u||(h.as="script"),h.crossOrigin="",h.href=d,o&&h.setAttribute("nonce",o),document.head.appendChild(h),u)return new Promise((p,y)=>{h.addEventListener("load",p),h.addEventListener("error",()=>y(new Error(`Unable to preload CSS for ${d}`)))})}))}function a(s){const o=new Event("vite:preloadError",{cancelable:!0});if(o.payload=s,window.dispatchEvent(o),!o.defaultPrevented)throw s}return n.then(s=>{for(const o of s||[])o.status==="rejected"&&a(o.reason);return t().catch(a)})};function gt(e,t){if(!Number.isInteger(t)||t<=0)throw new Error("Size must be an integer greater than zero.");const r=Math.ceil(e.length/t),i=Array(r);for(let n=0;n<r;n++){const a=n*t,l=a+t;i[n]=e.slice(a,l)}return i}const xt="/assets/object-detect-DKSFrVWF.onnx",Et="/assets/text-detect-Cl_XIpL2.onnx",Mt="/assets/text-recognition-BGsAHInl.onnx",At=(e,t)=>{const r=typeof document<"u"?document.createElement("canvas"):new OffscreenCanvas(1,1);r.width=e.dims[3],r.height=e.dims[2];const i=r.getContext("2d");if(i!=null){let n,a;t?.tensorLayout!==void 0&&t.tensorLayout==="NHWC"?(n=e.dims[2],a=e.dims[3]):(n=e.dims[3],a=e.dims[2]);const l=t?.format!==void 0?t.format:"RGB",s=t?.norm;let o,c;s===void 0||s.mean===void 0?o=[255,255,255,255]:typeof s.mean=="number"?o=[s.mean,s.mean,s.mean,s.mean]:(o=[s.mean[0],s.mean[1],s.mean[2],0],s.mean[3]!==void 0&&(o[3]=s.mean[3])),s===void 0||s.bias===void 0?c=[0,0,0,0]:typeof s.bias=="number"?c=[s.bias,s.bias,s.bias,s.bias]:(c=[s.bias[0],s.bias[1],s.bias[2],0],s.bias[3]!==void 0&&(c[3]=s.bias[3]));const d=a*n;let u=0,f=d,h=d*2,p=-1;l==="RGBA"?(u=0,f=d,h=d*2,p=d*3):l==="RGB"?(u=0,f=d,h=d*2):l==="RBG"&&(u=0,h=d,f=d*2);for(let y=0;y<a;y++)for(let w=0;w<n;w++){const m=(e.data[u++]-c[0])*o[0],T=(e.data[f++]-c[1])*o[1],x=(e.data[h++]-c[2])*o[2],b=p===-1?255:(e.data[p++]-c[3])*o[3];i.fillStyle="rgba("+m+","+T+","+x+","+b+")",i.fillRect(w,y,1,1)}if("toDataURL"in r)return r.toDataURL();throw new Error("toDataURL is not supported")}else throw new Error("Can not access image data")},Rt=(e,t)=>{const r=typeof document<"u"?document.createElement("canvas").getContext("2d"):new OffscreenCanvas(1,1).getContext("2d");let i;if(r!=null){let n,a,l;t?.tensorLayout!==void 0&&t.tensorLayout==="NHWC"?(n=e.dims[2],a=e.dims[1],l=e.dims[3]):(n=e.dims[3],a=e.dims[2],l=e.dims[1]);const s=t!==void 0&&t.format!==void 0?t.format:"RGB",o=t?.norm;let c,d;o===void 0||o.mean===void 0?c=[255,255,255,255]:typeof o.mean=="number"?c=[o.mean,o.mean,o.mean,o.mean]:(c=[o.mean[0],o.mean[1],o.mean[2],255],o.mean[3]!==void 0&&(c[3]=o.mean[3])),o===void 0||o.bias===void 0?d=[0,0,0,0]:typeof o.bias=="number"?d=[o.bias,o.bias,o.bias,o.bias]:(d=[o.bias[0],o.bias[1],o.bias[2],0],o.bias[3]!==void 0&&(d[3]=o.bias[3]));const u=a*n;if(t!==void 0&&(t.format!==void 0&&l===4&&t.format!=="RGBA"||l===3&&t.format!=="RGB"&&t.format!=="BGR"))throw new Error("Tensor format doesn't match input tensor dims");const f=4;let h=0,p=1,y=2,w=3,m=0,T=u,x=u*2,b=-1;s==="RGBA"?(m=0,T=u,x=u*2,b=u*3):s==="RGB"?(m=0,T=u,x=u*2):s==="RBG"&&(m=0,x=u,T=u*2),i=r.createImageData(n,a);for(let A=0;A<a*n;h+=f,p+=f,y+=f,w+=f,A++)i.data[h]=(e.data[m++]-d[0])*c[0],i.data[p]=(e.data[T++]-d[1])*c[1],i.data[y]=(e.data[x++]-d[2])*c[2],i.data[w]=b===-1?255:(e.data[b++]-d[3])*c[3]}else throw new Error("Can not access image data");return i},rt=(e,t)=>{if(e===void 0)throw new Error("Image buffer must be defined");if(t.height===void 0||t.width===void 0)throw new Error("Image height and width must be defined");if(t.tensorLayout==="NHWC")throw new Error("NHWC Tensor layout is not supported yet");const{height:r,width:i}=t,n=t.norm??{mean:255,bias:0};let a,l;typeof n.mean=="number"?a=[n.mean,n.mean,n.mean,n.mean]:a=[n.mean[0],n.mean[1],n.mean[2],n.mean[3]??255],typeof n.bias=="number"?l=[n.bias,n.bias,n.bias,n.bias]:l=[n.bias[0],n.bias[1],n.bias[2],n.bias[3]??0];const s=t.format!==void 0?t.format:"RGBA",o=t.tensorFormat!==void 0&&t.tensorFormat!==void 0?t.tensorFormat:"RGB",c=r*i,d=o==="RGBA"?new Float32Array(c*4):new Float32Array(c*3);let u=4,f=0,h=1,p=2,y=3,w=0,m=c,T=c*2,x=-1;s==="RGB"&&(u=3,f=0,h=1,p=2,y=-1),o==="RGBA"?x=c*3:o==="RBG"?(w=0,T=c,m=c*2):o==="BGR"&&(T=0,m=c,w=c*2);for(let A=0;A<c;A++,f+=u,p+=u,h+=u,y+=u)d[w++]=(e[f]+l[0])/a[0],d[m++]=(e[h]+l[1])/a[1],d[T++]=(e[p]+l[2])/a[2],x!==-1&&y!==-1&&(d[x++]=(e[y]+l[3])/a[3]);return o==="RGBA"?new N("float32",d,[1,4,r,i]):new N("float32",d,[1,3,r,i])},Ct=async(e,t)=>{const r=typeof HTMLImageElement<"u"&&e instanceof HTMLImageElement,i=typeof ImageData<"u"&&e instanceof ImageData,n=typeof ImageBitmap<"u"&&e instanceof ImageBitmap,a=typeof e=="string";let l,s=t??{};const o=()=>{if(typeof document<"u")return document.createElement("canvas");if(typeof OffscreenCanvas<"u")return new OffscreenCanvas(1,1);throw new Error("Canvas is not supported")},c=d=>typeof HTMLCanvasElement<"u"&&d instanceof HTMLCanvasElement||d instanceof OffscreenCanvas?d.getContext("2d"):null;if(r){const d=o();d.width=e.width,d.height=e.height;const u=c(d);if(u!=null){let f=e.height,h=e.width;if(t!==void 0&&t.resizedHeight!==void 0&&t.resizedWidth!==void 0&&(f=t.resizedHeight,h=t.resizedWidth),t!==void 0){if(s=t,t.tensorFormat!==void 0)throw new Error("Image input config format must be RGBA for HTMLImageElement");s.tensorFormat="RGBA",s.height=f,s.width=h}else s.tensorFormat="RGBA",s.height=f,s.width=h;u.drawImage(e,0,0),l=u.getImageData(0,0,h,f).data}else throw new Error("Can not access image data")}else if(i){let d,u;if(t!==void 0&&t.resizedWidth!==void 0&&t.resizedHeight!==void 0?(d=t.resizedHeight,u=t.resizedWidth):(d=e.height,u=e.width),t!==void 0&&(s=t),s.format="RGBA",s.height=d,s.width=u,t!==void 0){const f=o();f.width=u,f.height=d;const h=c(f);if(h!=null)h.putImageData(e,0,0),l=h.getImageData(0,0,u,d).data;else throw new Error("Can not access image data")}else l=e.data}else if(n){if(t===void 0)throw new Error("Please provide image config with format for Imagebitmap");const d=o();d.width=e.width,d.height=e.height;const u=c(d);if(u!=null){const f=e.height,h=e.width;return u.drawImage(e,0,0,h,f),l=u.getImageData(0,0,h,f).data,s.height=f,s.width=h,rt(l,s)}else throw new Error("Can not access image data")}else{if(a)return new Promise((d,u)=>{const f=o(),h=c(f);if(!e||!h)return u();const p=new Image;p.crossOrigin="Anonymous",p.src=e,p.onload=()=>{f.width=p.width,f.height=p.height,h.drawImage(p,0,0,f.width,f.height);const y=h.getImageData(0,0,f.width,f.height);s.height=f.height,s.width=f.width,d(rt(y.data,s))}});throw new Error("Input data provided is not supported - aborted tensor creation")}if(l!==void 0)return rt(l,s);throw new Error("Input data provided is not supported - aborted tensor creation")},It=(e,t)=>{const{width:r,height:i,download:n,dispose:a}=t,l=[1,i,r,4];return new N({location:"texture",type:"float32",texture:e,dims:l,download:n,dispose:a})},Pt=(e,t)=>{const{dataType:r,dims:i,download:n,dispose:a}=t;return new N({location:"gpu-buffer",type:r??"float32",gpuBuffer:e,dims:i,download:n,dispose:a})},_t=(e,t)=>{const{dataType:r,dims:i,download:n,dispose:a}=t;return new N({location:"ml-tensor",type:r??"float32",mlTensor:e,dims:i,download:n,dispose:a})},Bt=(e,t,r)=>new N({location:"cpu-pinned",type:e,data:t,dims:r??[t.length]}),Y=new Map([["float32",Float32Array],["uint8",Uint8Array],["int8",Int8Array],["uint16",Uint16Array],["int16",Int16Array],["int32",Int32Array],["bool",Uint8Array],["float64",Float64Array],["uint32",Uint32Array],["int4",Uint8Array],["uint4",Uint8Array]]),et=new Map([[Float32Array,"float32"],[Uint8Array,"uint8"],[Int8Array,"int8"],[Uint16Array,"uint16"],[Int16Array,"int16"],[Int32Array,"int32"],[Float64Array,"float64"],[Uint32Array,"uint32"]]);let ut=!1;const Ot=()=>{if(!ut){ut=!0;const e=typeof BigInt64Array<"u"&&BigInt64Array.from,t=typeof BigUint64Array<"u"&&BigUint64Array.from,r=globalThis.Float16Array,i=typeof r<"u"&&r.from;e&&(Y.set("int64",BigInt64Array),et.set(BigInt64Array,"int64")),t&&(Y.set("uint64",BigUint64Array),et.set(BigUint64Array,"uint64")),i?(Y.set("float16",r),et.set(r,"float16")):Y.set("float16",Uint16Array)}},Dt=e=>{let t=1;for(let r=0;r<e.length;r++){const i=e[r];if(typeof i!="number"||!Number.isSafeInteger(i))throw new TypeError(`dims[${r}] must be an integer, got: ${i}`);if(i<0)throw new RangeError(`dims[${r}] must be a non-negative integer, got: ${i}`);t*=i}return t},Lt=(e,t)=>{switch(e.location){case"cpu":return new N(e.type,e.data,t);case"cpu-pinned":return new N({location:"cpu-pinned",data:e.data,type:e.type,dims:t});case"texture":return new N({location:"texture",texture:e.texture,type:e.type,dims:t});case"gpu-buffer":return new N({location:"gpu-buffer",gpuBuffer:e.gpuBuffer,type:e.type,dims:t});case"ml-tensor":return new N({location:"ml-tensor",mlTensor:e.mlTensor,type:e.type,dims:t});default:throw new Error(`tensorReshape: tensor location ${e.location} is not supported`)}};let N=class{constructor(t,r,i){Ot();let n,a;if(typeof t=="object"&&"location"in t)switch(this.dataLocation=t.location,n=t.type,a=t.dims,t.location){case"cpu-pinned":{const s=Y.get(n);if(!s)throw new TypeError(`unsupported type "${n}" to create tensor from pinned buffer`);if(!(t.data instanceof s))throw new TypeError(`buffer should be of type ${s.name}`);this.cpuData=t.data;break}case"texture":{if(n!=="float32")throw new TypeError(`unsupported type "${n}" to create tensor from texture`);this.gpuTextureData=t.texture,this.downloader=t.download,this.disposer=t.dispose;break}case"gpu-buffer":{if(n!=="float32"&&n!=="float16"&&n!=="int32"&&n!=="int64"&&n!=="uint32"&&n!=="uint8"&&n!=="bool"&&n!=="uint4"&&n!=="int4")throw new TypeError(`unsupported type "${n}" to create tensor from gpu buffer`);this.gpuBufferData=t.gpuBuffer,this.downloader=t.download,this.disposer=t.dispose;break}case"ml-tensor":{if(n!=="float32"&&n!=="float16"&&n!=="int32"&&n!=="int64"&&n!=="uint32"&&n!=="uint64"&&n!=="int8"&&n!=="uint8"&&n!=="bool"&&n!=="uint4"&&n!=="int4")throw new TypeError(`unsupported type "${n}" to create tensor from MLTensor`);this.mlTensorData=t.mlTensor,this.downloader=t.download,this.disposer=t.dispose;break}default:throw new Error(`Tensor constructor: unsupported location '${this.dataLocation}'`)}else{let s,o;if(typeof t=="string")if(n=t,o=i,t==="string"){if(!Array.isArray(r))throw new TypeError("A string tensor's data must be a string array.");s=r}else{const c=Y.get(t);if(c===void 0)throw new TypeError(`Unsupported tensor type: ${t}.`);if(Array.isArray(r)){if(t==="float16"&&c===Uint16Array||t==="uint4"||t==="int4")throw new TypeError(`Creating a ${t} tensor from number array is not supported. Please use ${c.name} as data.`);t==="uint64"||t==="int64"?s=c.from(r,BigInt):s=c.from(r)}else if(r instanceof c)s=r;else if(r instanceof Uint8ClampedArray)if(t==="uint8")s=Uint8Array.from(r);else throw new TypeError("A Uint8ClampedArray tensor's data must be type of uint8");else if(t==="float16"&&r instanceof Uint16Array&&c!==Uint16Array)s=new globalThis.Float16Array(r.buffer,r.byteOffset,r.length);else throw new TypeError(`A ${n} tensor's data must be type of ${c}`)}else if(o=r,Array.isArray(t)){if(t.length===0)throw new TypeError("Tensor type cannot be inferred from an empty array.");const c=typeof t[0];if(c==="string")n="string",s=t;else if(c==="boolean")n="bool",s=Uint8Array.from(t);else throw new TypeError(`Invalid element type of data array: ${c}.`)}else if(t instanceof Uint8ClampedArray)n="uint8",s=Uint8Array.from(t);else{const c=et.get(t.constructor);if(c===void 0)throw new TypeError(`Unsupported type for tensor data: ${t.constructor}.`);n=c,s=t}if(o===void 0)o=[s.length];else if(!Array.isArray(o))throw new TypeError("A tensor's dims must be a number array");a=o,this.cpuData=s,this.dataLocation="cpu"}const l=Dt(a);if(this.cpuData&&l!==this.cpuData.length&&!((n==="uint4"||n==="int4")&&Math.ceil(l/2)===this.cpuData.length))throw new Error(`Tensor's size(${l}) does not match data length(${this.cpuData.length}).`);this.type=n,this.dims=a,this.size=l}static async fromImage(t,r){return Ct(t,r)}static fromTexture(t,r){return It(t,r)}static fromGpuBuffer(t,r){return Pt(t,r)}static fromMLTensor(t,r){return _t(t,r)}static fromPinnedBuffer(t,r,i){return Bt(t,r,i)}toDataURL(t){return At(this,t)}toImageData(t){return Rt(this,t)}get data(){if(this.ensureValid(),!this.cpuData)throw new Error("The data is not on CPU. Use `getData()` to download GPU data to CPU, or use `texture` or `gpuBuffer` property to access the GPU data directly.");return this.cpuData}get location(){return this.dataLocation}get texture(){if(this.ensureValid(),!this.gpuTextureData)throw new Error("The data is not stored as a WebGL texture.");return this.gpuTextureData}get gpuBuffer(){if(this.ensureValid(),!this.gpuBufferData)throw new Error("The data is not stored as a WebGPU buffer.");return this.gpuBufferData}get mlTensor(){if(this.ensureValid(),!this.mlTensorData)throw new Error("The data is not stored as a WebNN MLTensor.");return this.mlTensorData}async getData(t){switch(this.ensureValid(),this.dataLocation){case"cpu":case"cpu-pinned":return this.data;case"texture":case"gpu-buffer":case"ml-tensor":{if(!this.downloader)throw new Error("The current tensor is not created with a specified data downloader.");if(this.isDownloading)throw new Error("The current tensor is being downloaded.");try{this.isDownloading=!0;const r=await this.downloader();return this.downloader=void 0,this.dataLocation="cpu",this.cpuData=r,t&&this.disposer&&(this.disposer(),this.disposer=void 0),r}finally{this.isDownloading=!1}}default:throw new Error(`cannot get data from location: ${this.dataLocation}`)}}dispose(){if(this.isDownloading)throw new Error("The current tensor is being downloaded.");this.disposer&&(this.disposer(),this.disposer=void 0),this.cpuData=void 0,this.gpuTextureData=void 0,this.gpuBufferData=void 0,this.mlTensorData=void 0,this.downloader=void 0,this.isDownloading=void 0,this.dataLocation="none"}ensureValid(){if(this.dataLocation==="none")throw new Error("The tensor is disposed.")}reshape(t){if(this.ensureValid(),this.downloader||this.disposer)throw new Error("Cannot reshape a tensor that owns GPU resource.");return Lt(this,t)}};const ct=N;function wt(e){return 1/(1+Math.exp(-e))}function vt(e,t){return Math.hypot(e.x-t.x,e.y-t.y)}function W(e,t){const r=t.y-e.y,i=t.x-e.x;return(360-Math.atan2(r,i)*180/Math.PI)%360}function S(e,t,r){return Math.min(Math.max(e,t),r)}function St(e){return e.indexOf(Math.max(...e))}function Nt(e){const t=Math.max(...e),r=e.map(n=>Math.exp(n-t)),i=r.reduce((n,a)=>n+a,0);return r.map(n=>n/i)}function at(e){if(e===null||typeof e!="object")return!1;const t=Object.getPrototypeOf(e);return t!==null&&t!==Object.prototype&&Object.getPrototypeOf(t)!==null||Symbol.iterator in e?!1:Symbol.toStringTag in e?Object.prototype.toString.call(e)==="[object Module]":!0}function it(e,t,r=".",i){if(!at(t))return it(e,{},r,i);const n=Object.assign({},t);for(const a in e){if(a==="__proto__"||a==="constructor")continue;const l=e[a];l!=null&&(i&&i(n,a,l,r)||(Array.isArray(l)&&Array.isArray(n[a])?n[a]=[...l,...n[a]]:at(l)&&at(n[a])?n[a]=it(l,n[a],(r?`${r}.`:"")+a.toString(),i):n[a]=l))}return n}function Ut(e){return(...t)=>t.reduce((r,i)=>it(r,i,"",e),{})}const mt=Ut();let st;async function D(){if(!st){const{default:e}=await ht(async()=>{const{default:t}=await import("./opencv-Cg6dp1wg.js").then(r=>r.o);return{default:t}},__vite__mapDeps([0,1]));st=e instanceof Promise?await e:e}return st}async function nt(e){const t=await D();if(e instanceof t.Mat)return e.clone();const r=new Image;return r.src=e instanceof Blob?URL.createObjectURL(e):e,await r.decode(),e instanceof Blob&&URL.revokeObjectURL(r.src),t.imread(r)}async function Gt(e,t,r=10){const i=await D(),n=new i.Mat,a=new i.MatVector;i.cvtColor(e,n,i.COLOR_RGBA2GRAY),a.push_back(n);const l=256,s=[0,256],o=new i.Mat,c=new i.Mat;i.calcHist(a,[0],c,o,[l],s);const d=[o.data32F[0]];for(let m=1;m<l;m++)d[m]=d[m-1]+o.data32F[m];const u=d[l-1],f=r*u/100/2;let h=0;for(;d[h]<f;)h++;let p=l-1;for(;d[p]>=u-f;)p--;const y=255/(p-h),w=-h*y;e.convertTo(t,-1,y,w),a.delete(),n.delete(),o.delete(),c.delete()}function Ft(e,t,r,i=.5){for(let n=0;n<e.rows;n++)for(let a=0;a<e.cols;a++){const l=t.ucharPtr(n,a)[0],s=i*l/255,o=1-s,c=e.ucharPtr(n,a);for(let d=0;d<e.channels();d++)c[d]=c[d]*o+r[d]*s}}var pt=(e=>(e[e.TOP_LEFT=0]="TOP_LEFT",e[e.TOP_CENTER=1]="TOP_CENTER",e[e.TOP_RIGHT=2]="TOP_RIGHT",e[e.MID_LEFT=4]="MID_LEFT",e[e.MID_CENTER=5]="MID_CENTER",e[e.MID_RIGHT=6]="MID_RIGHT",e[e.BOTTOM_LEFT=8]="BOTTOM_LEFT",e[e.BOTTOM_CENTER=9]="BOTTOM_CENTER",e[e.BOTTOM_RIGHT=10]="BOTTOM_RIGHT",e))(pt||{});function dt(e,t,r=5){const i=Math.min(t.width/e.width,t.height/e.height),n=Math.floor(e.width*i),a=Math.floor(e.height*i),l=t.width-n,s=t.height-a;let o=0,c=0;r&1?o=Math.floor(l/2):r&2&&(o=l),r&4?c=Math.floor(s/2):r&8&&(c=s);async function d(w,m,T,x){const b=await D();b.resize(w,m,new b.Size(n,a),0,0,x??b.INTER_CUBIC),b.copyMakeBorder(m,m,c,s-c,o,l-o,b.BORDER_CONSTANT,T??new b.Scalar(0,0,0,255))}async function u(w){const m=await D(),T=await f(new m.Point(w.x,w.y)),x=await f(new m.Point(w.x+w.width,w.y+w.height),!0);return new m.Rect(S(T.x,0,n),S(T.y,0,a),S(x.x-T.x,0,n),S(x.y-T.y,0,a))}async function f(w,m=!1){const T=await D(),x=m?Math.ceil(w.x*i):Math.floor(w.x*i),b=m?Math.ceil(w.y*i):Math.floor(w.y*i);return new T.Point(S(x,0,n),S(b,0,a))}async function h(w,m,T){const x=await D(),b=new x.Rect(o,c,n,a),A=w.roi(b);x.resize(A,m,e,0,0,T??x.INTER_CUBIC),A.delete()}async function p(w){const m=await D(),T=await y(new m.Point(w.x,w.y)),x=await y(new m.Point(w.x+w.width,w.y+w.height),!0);return new m.Rect(T.x,T.y,x.x-T.x,x.y-T.y)}async function y(w,m=!1){const T=await D(),x=m?Math.ceil((w.x-o)/i):Math.floor((w.x-o)/i),b=m?Math.ceil((w.y-c)/i):Math.floor((w.y-c)/i);return new T.Point(S(x,0,e.width),S(b,0,e.height))}return{scaleMat:d,scaleRect:u,scalePoint:f,revertMat:h,revertRect:p,revertPoint:y}}function Ht({model:e,labels:t}){const r=e.inputMetadata[0],i=e.outputMetadata[0],n=e.outputMetadata[1];async function a(l,s){const o=mt(s,{confidence:.8}),c=await D(),d=await nt(l),u=d.size(),f=new c.Size(r.shape[3],r.shape[2]),h=dt(u,f),p=new c.Mat,y=new c.Mat;await h.scaleMat(d,p),c.cvtColor(p,y,c.COLOR_RGBA2BGR);const w=c.blobFromImage(y,1/255,y.size(),new c.Scalar(0,0,0),!0,!1),m=new ct("float32",w.data32F,r.shape),T=await e.run({[r.name]:m}),x=T[i.name],b=T[n.name],A=i.shape[1],_=i.shape[2],R=x.data,B=b.data,C=n.shape[1],g=new c.Size(n.shape[3],n.shape[2]),I=g.width*g.height,P=[];for(let M=0;M<A;M++){const E=M*_,U=R[E+4],G=R[E+5];if(U<o.confidence||G<0||G>=t.length)continue;const L=S(Math.floor(R[E]),0,f.width),q=S(Math.floor(R[E+1]),0,f.height),z=S(Math.ceil(R[E+2]),0,f.width),X=S(Math.ceil(R[E+3]),0,f.height),ot=R.slice(E+6,E+6+C),K=Float32Array.from({length:I},($,F)=>{let V=0;for(let j=0;j<C;j++)V+=ot[j]*B[j*I+F];return wt(V)}),Z=new c.Rect(L,q,z-L,X-q),k=c.matFromArray(g.height,g.width,c.CV_8UC1,Uint8ClampedArray.from(K,$=>$*255));c.resize(k,k,f,0,0,c.INTER_CUBIC),await h.revertMat(k,k);const O=await h.revertRect(Z),v=k.roi(O);P.push({classId:G,label:t[G],confidence:U,bbox:[O.x,O.y,O.x+O.width,O.y+O.height],mask:Uint8ClampedArray.from({length:v.rows*v.cols},($,F)=>{const V=Math.floor(F/v.cols),j=F%v.cols;return v.ucharPtr(V,j)[0]})}),k.delete(),v.delete()}return m.dispose(),x.dispose(),b.dispose(),d.delete(),p.delete(),y.delete(),w.delete(),P}return{predict:a}}function J(e,t){const[r,i,n,a]=e,[l,s,o,c]=t,d=a-i,u=r-n,f=d*r+u*i,h=c-s,p=l-o,y=h*l+p*s,w=d*p-h*u;if(w===0)return;const m=(p*f-u*y)/w,T=(d*y-h*f)/w;return[m,T]}function Q(e,t,r=!1){const i=e.length;if(!(i<2))if(r){let n=0,a=0,l=0,s=0;for(const{x:p,y}of e)n+=p,a+=y,l+=p*y,s+=y*y;const o=(i*l-a*n)/(i*s-a*a+1e-6),c=(n-o*a)/i,d=0,u=o*0+c,f=t.height,h=o*t.height+c;return[u,d,h,f]}else{let n=0,a=0,l=0,s=0;for(const{x:p,y}of e)n+=p,a+=y,l+=p*y,s+=p*p;const o=(i*l-n*a)/(i*s-n*n+1e-6),c=(a-o*n)/i,d=0,u=o*0+c,f=t.width,h=o*t.width+c;return[d,u,f,h]}}async function kt(e){const t=await D(),r=t.minAreaRect(e),i=r.center;let n=new t.Point(0,0),a=0,l=new t.Point(0,0),s=0,o=new t.Point(0,0),c=0,d=new t.Point(0,0),u=0;for(let P=0;P<e.data32S.length;P+=2){const M=new t.Point(e.data32S[P],e.data32S[P+1]),E=vt(M,i);M.x<i.x&&M.y<i.y?E>a&&(n=M,a=E):M.x>i.x&&M.y<i.y?E>s&&(l=M,s=E):M.x<i.x&&M.y>i.y?E>c&&(o=M,c=E):M.x>i.x&&M.y>i.y&&E>u&&(d=M,u=E)}const f=W(i,l),h=W(i,n),p=W(i,o),y=W(i,d),w=[n,l],m=[o,d],T=[n,o],x=[l,d];for(let P=0;P<e.data32S.length;P+=2){const M=new t.Point(e.data32S[P],e.data32S[P+1]),E=W(i,M);E>f&&E<h?w.push(M):E>h&&E<p?T.push(M):E>p&&E<y?m.push(M):(E>y||E<f)&&x.push(M)}const b=Q(w,r.size),A=Q(m,r.size),_=Q(T,r.size,!0),R=Q(x,r.size,!0);if(!b||!A||!_||!R)return[n,l,o,d];const B=J(b,_),C=J(b,R),g=J(A,R),I=J(A,_);return!B||!C||!g||!I?[n,l,o,d]:[new t.Point(B[0],B[1]),new t.Point(C[0],C[1]),new t.Point(I[0],I[1]),new t.Point(g[0],g[1])]}async function ft(e){let t=-1,r=Number.NEGATIVE_INFINITY;const i=await D();for(let n=0;n<e.size();n++){const a=e.get(n),l=i.contourArea(a);l>r&&(r=l,t=n),a.delete()}return t}async function $t(e,t){const r=await D(),i=new r.Mat,n=new r.Mat;r.bitwise_and(e,t,i),r.bitwise_or(e,t,n);const a=r.countNonZero(i),l=r.countNonZero(n),s=l>0?a/l:0;return i.delete(),n.delete(),s}async function Vt(e,t,r,i,n){const a=await D(),l=new a.MatVector,s=new a.Mat,o=e.roi(r);a.cvtColor(o,o,a.COLOR_RGBA2GRAY);for(let d=0;d<o.rows;d++)for(let u=0;u<o.cols;u++)o.ucharPtr(d,u)[0]=Math.floor(o.ucharPtr(d,u)[0]*(i.ucharPtr(d,u)[0]/255));a.threshold(o,o,128,255,a.THRESH_BINARY+a.THRESH_OTSU),a.findContours(o,l,s,a.RETR_EXTERNAL,a.CHAIN_APPROX_SIMPLE);let c=await ft(l);if(c>-1){const d=l.get(c),u=new a.Mat;a.convexHull(d,u,!0,!0),l.set(c,u),d.delete();const f=a.Mat.zeros(i.rows,i.cols,a.CV_8UC1);if(a.drawContours(f,l,c,new a.Scalar(255),a.FILLED),await $t(f,i)<.9&&(a.findContours(i,l,s,a.RETR_EXTERNAL,a.CHAIN_APPROX_SIMPLE),c=await ft(l),c>-1)){const A=l.get(c);a.convexHull(A,u,!0,!0),l.set(c,u),A.delete()}f.delete();const p=await kt(u),y=r.height>r.width,w=y?n.height:n.width,m=y?n.width:n.height,T=a.matFromArray(4,1,a.CV_32FC2,p.flatMap(({x:A,y:_})=>[r.x+A,r.y+_])),x=a.matFromArray(4,1,a.CV_32FC2,[0,0,w,0,0,m,w,m]),b=a.getPerspectiveTransform(T,x);a.warpPerspective(e,t,b,new a.Size(w,m),a.INTER_CUBIC,a.BORDER_CONSTANT,new a.Scalar),y&&a.rotate(t,t,a.ROTATE_90_COUNTERCLOCKWISE),T.delete(),x.delete(),u.delete()}l.delete(),s.delete(),o.delete()}function jt({model:e}){const t=e.inputMetadata[0],r=e.outputMetadata[0];async function i(n,a){const l=mt(a,{confidence:.3,unclipRatio:1.75,boxMinArea:64}),s=await D(),o=await nt(n),c=o.size(),d=new s.Size(t.shape[3],t.shape[2]),u=dt(c,d),f=new s.Mat,h=new s.Mat;await u.scaleMat(o,f),s.cvtColor(f,h,s.COLOR_RGBA2BGR);const p=s.blobFromImage(h,1/255,h.size(),new s.Scalar(0,0,0),!0,!1),y=new ct("float32",p.data32F,[1,...t.shape.slice(1)]),m=(await e.run({[t.name]:y}))[r.name],T=m.data,x=s.matFromArray(r.shape[3],r.shape[2],s.CV_8UC1,Uint8ClampedArray.from(T,R=>wt(R)>=l.confidence?255:0)),b=new s.MatVector,A=new s.Mat;s.findContours(x,b,A,s.RETR_EXTERNAL,s.CHAIN_APPROX_SIMPLE);const _=[];for(let R=0;R<b.size();R++){const B=b.get(R),C=new s.Mat;s.convexHull(B,C,!0,!0);const g=s.contourArea(C),I=s.arcLength(C,!0);if(g>l.boxMinArea&&I>0){const P=Math.ceil(g*l.unclipRatio/I),M=s.boundingRect(B),E=await u.revertRect(new s.Rect(M.x-P,M.y-P,M.width+P*2,M.height+P*2));_.push({bbox:[E.x,E.y,E.x+E.width,E.y+E.height]})}C.delete(),B.delete()}return y.dispose(),m.dispose(),x.delete(),p.delete(),f.delete(),h.delete(),o.delete(),_.sort((R,B)=>B.bbox[0]-R.bbox[0]),_}return{predict:i}}const Yt="0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ!\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~°£€¥¢฿àâéèêëîïôùûüçÀÂÉÈÊËÎÏÔÙÛÜÇ";function zt({model:e,vocab:t=Yt}){const r=e.inputMetadata[0],i=e.outputMetadata[0];async function n(l){const s=await D(),o=await Promise.all(l.map(async b=>{const A=await nt(b),_=A.size(),R=new s.Size(r.shape[3],r.shape[2]),B=dt(_,R,pt.MID_LEFT),C=new s.Mat,g=new s.Mat;await B.scaleMat(A,C,new s.Scalar(255,255,255,255)),s.cvtColor(C,g,s.COLOR_RGBA2BGR);const I=s.blobFromImage(g,1/255,g.size(),new s.Scalar(0,0,0),!0,!1);return C.delete(),g.delete(),A.delete(),I})),c=[o.length,...r.shape.slice(1)],d=new Float32Array(c.reduce((b,A)=>b*A,1));for(const b of o){const A=o.indexOf(b)*c.slice(1).reduce((_,R)=>_*R,1);d.set(b.data32F,A),b.delete()}const u=new ct("float32",d,c),h=(await e.run({[r.name]:u}))[i.name],p=h.data,[y,w,m]=h.dims,T=m-1,x=[];for(let b=0;b<y;b++){const A=[],_=b*w*m;let R=1;for(let g=0;g<w;g++){const I=g*m+_,P=p.slice(I,I+m),M=Nt(P),E=St(M);A.push(E),M[E]<R&&(R=M[E])}const B=[];let C=-1;for(const g of A)g!==C&&g!==T&&B.push(g),C=g;x.push(B.map(g=>t[g]).join(""))}return u.dispose(),h.dispose(),x}async function a(l){return(await n([l]))[0]}return{predict:a,predictBatch:n}}function tt(e,t){return`${((t-e)/1e3).toFixed(2)}s`}function H(e){document.querySelector("#note").textContent=e}async function Xt(){const e=document.querySelector("#fileinput"),t=document.querySelector("#input"),r=document.querySelector("#crop"),i=document.querySelector("#output"),n=document.querySelector("#filter"),a=document.querySelector("#grayed"),l=document.querySelector("#text-mask"),s=document.querySelector("#recognized");H("Initiating OpenCV ...");const o=await D();H("Initiating ONNX Runtime ...");const c=await ht(()=>import("./ort.bundle.min-D7xVg6BR.js"),__vite__mapDeps([2,1]));H("Initiating YOLO Model ...");const d=Ht({model:await c.default.InferenceSession.create(xt),labels:["kartu","ktp","ktp-fc"]});e.disabled=!1,H("Initiating DBNet Model ...");const u=jt({model:await c.InferenceSession.create(Et)});H("Initiating CRNN Model ...");const f=zt({model:await c.InferenceSession.create(Mt)});H("Ready!");const h=[new o.Scalar(0,255,0,255),new o.Scalar(0,0,255,255),new o.Scalar(255,0,0,255)];let p=0,y=0,w=0,m=0,T=0,x=0,b=0,A=0;e.addEventListener("input",async()=>{const _=e.files?.[0];if(!_)return;p=performance.now();const R=await nt(_);o.imshow(t,R),w=performance.now();const B=await d.predict(R);m=performance.now();const C=B.find(g=>{const I=g.bbox[2]-g.bbox[0],P=g.bbox[3]-g.bbox[1],M=Math.max(I,P),E=Math.min(I,P),U=M/E;return g.classId===1&&M>100&&U>1&&U<2});if(C){const g=new o.Mat,I=new o.Rect(C.bbox[0],C.bbox[1],C.bbox[2]-C.bbox[0],C.bbox[3]-C.bbox[1]),P=o.matFromArray(I.height,I.width,o.CV_8UC1,C.mask),M=R.roi(I),E=new o.Mat,U=new o.MatVector;o.split(M,U),U.set(3,P),o.merge(U,E),o.imshow(r,E),await Vt(R,g,I,P,new o.Size(1024,646));const G=new o.Mat,L=new o.Mat;await Gt(g,G,5),Ft(M,P,h[C.classId],.4),o.cvtColor(G,L,o.COLOR_RGBA2GRAY),o.cvtColor(L,L,o.COLOR_GRAY2RGBA),o.rectangle(R,new o.Point(I.x,I.y),new o.Point(I.x+I.width,I.y+I.height),h[C.classId],2),o.putText(R,C.label,new o.Point(I.x+10,I.y+20),o.FONT_HERSHEY_SIMPLEX,.7,new o.Scalar(255,255,255,255),1,o.LINE_AA,!1),T=performance.now();const q=await u.predict(L),z=new o.Mat(L.rows,L.cols,g.type(),new o.Scalar(255,255,255,255)),X=new o.Mat(L.rows,L.cols,g.type(),new o.Scalar(255,255,255,255));x=performance.now();const ot=gt(q,32);b=performance.now();for(const K of ot){const Z=K.map(O=>{const v=new o.Rect(O.bbox[0],O.bbox[1],O.bbox[2]-O.bbox[0],O.bbox[3]-O.bbox[1]),$=L.roi(v),F=z.roi(v);return $.copyTo(F),F.delete(),$}),k=await f.predictBatch(Z);for(const[O,v]of K.entries()){const $=k[O],F=Z[O],V=new o.Point(v.bbox[0],v.bbox[1]),j=new o.Point(v.bbox[2],v.bbox[3]),yt=new o.Point(V.x+10,V.y+Math.floor((j.y-V.y)/2)+8);o.putText(X,$,yt,o.FONT_HERSHEY_SIMPLEX,.7,new o.Scalar(0,0,0,255),2,o.LINE_AA,!1),F.delete()}}A=performance.now(),o.imshow(t,R),o.imshow(i,g),o.imshow(n,G),o.imshow(a,L),o.imshow(l,z),o.imshow(s,X),M.delete(),U.delete(),P.delete(),E.delete(),z.delete(),X.delete(),y=performance.now(),G.delete(),L.delete(),g.delete(),H(`Success!
        Detect Object: ${tt(w,m)},
        Detect Text: ${tt(T,x)},
        Recognize Text: ${tt(b,A)},
        Total: ${tt(p,y)}
      `)}else{const g=o.Mat.zeros(404,640,o.CV_8UC4);o.imshow(r,g),o.imshow(i,g),o.imshow(n,g),o.imshow(a,g),g.delete(),H("Failed, Cannot find KTP in this image")}R.delete()})}document.addEventListener("DOMContentLoaded",()=>{Xt().catch(e=>{const t=e instanceof Error?e.message:e;H(`Error, ${t}`)})});
